// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace Sokol
{
    public enum SAPP_MAX
    {
        SAPP_MAX_TOUCHPOINTS = 8,
        SAPP_MAX_MOUSEBUTTONS = 3,
        SAPP_MAX_KEYCODES = 512,
        SAPP_MAX_ICONIMAGES = 8
    }

    public enum SappEventType
    {
        SAPP_EVENTTYPE_INVALID = 0,
        SAPP_EVENTTYPE_KEY_DOWN = 1,
        SAPP_EVENTTYPE_KEY_UP = 2,
        SAPP_EVENTTYPE_CHAR = 3,
        SAPP_EVENTTYPE_MOUSE_DOWN = 4,
        SAPP_EVENTTYPE_MOUSE_UP = 5,
        SAPP_EVENTTYPE_MOUSE_SCROLL = 6,
        SAPP_EVENTTYPE_MOUSE_MOVE = 7,
        SAPP_EVENTTYPE_MOUSE_ENTER = 8,
        SAPP_EVENTTYPE_MOUSE_LEAVE = 9,
        SAPP_EVENTTYPE_TOUCHES_BEGAN = 10,
        SAPP_EVENTTYPE_TOUCHES_MOVED = 11,
        SAPP_EVENTTYPE_TOUCHES_ENDED = 12,
        SAPP_EVENTTYPE_TOUCHES_CANCELLED = 13,
        SAPP_EVENTTYPE_RESIZED = 14,
        SAPP_EVENTTYPE_ICONIFIED = 15,
        SAPP_EVENTTYPE_RESTORED = 16,
        SAPP_EVENTTYPE_FOCUSED = 17,
        SAPP_EVENTTYPE_UNFOCUSED = 18,
        SAPP_EVENTTYPE_SUSPENDED = 19,
        SAPP_EVENTTYPE_RESUMED = 20,
        SAPP_EVENTTYPE_UPDATE_CURSOR = 21,
        SAPP_EVENTTYPE_QUIT_REQUESTED = 22,
        SAPP_EVENTTYPE_CLIPBOARD_PASTED = 23,
        SAPP_EVENTTYPE_FILES_DROPPED = 24,
        SAPP_EVENTTYPE_NUM = 25,
        SAPP_EVENTTYPE_FORCE_U32 = 2147483647
    }

    public enum SappKeycode
    {
        SAPP_KEYCODE_INVALID = 0,
        SAPP_KEYCODE_SPACE = 32,
        SAPP_KEYCODE_APOSTROPHE = 39,
        SAPP_KEYCODE_COMMA = 44,
        SAPP_KEYCODE_MINUS = 45,
        SAPP_KEYCODE_PERIOD = 46,
        SAPP_KEYCODE_SLASH = 47,
        SAPP_KEYCODE_0 = 48,
        SAPP_KEYCODE_1 = 49,
        SAPP_KEYCODE_2 = 50,
        SAPP_KEYCODE_3 = 51,
        SAPP_KEYCODE_4 = 52,
        SAPP_KEYCODE_5 = 53,
        SAPP_KEYCODE_6 = 54,
        SAPP_KEYCODE_7 = 55,
        SAPP_KEYCODE_8 = 56,
        SAPP_KEYCODE_9 = 57,
        SAPP_KEYCODE_SEMICOLON = 59,
        SAPP_KEYCODE_EQUAL = 61,
        SAPP_KEYCODE_A = 65,
        SAPP_KEYCODE_B = 66,
        SAPP_KEYCODE_C = 67,
        SAPP_KEYCODE_D = 68,
        SAPP_KEYCODE_E = 69,
        SAPP_KEYCODE_F = 70,
        SAPP_KEYCODE_G = 71,
        SAPP_KEYCODE_H = 72,
        SAPP_KEYCODE_I = 73,
        SAPP_KEYCODE_J = 74,
        SAPP_KEYCODE_K = 75,
        SAPP_KEYCODE_L = 76,
        SAPP_KEYCODE_M = 77,
        SAPP_KEYCODE_N = 78,
        SAPP_KEYCODE_O = 79,
        SAPP_KEYCODE_P = 80,
        SAPP_KEYCODE_Q = 81,
        SAPP_KEYCODE_R = 82,
        SAPP_KEYCODE_S = 83,
        SAPP_KEYCODE_T = 84,
        SAPP_KEYCODE_U = 85,
        SAPP_KEYCODE_V = 86,
        SAPP_KEYCODE_W = 87,
        SAPP_KEYCODE_X = 88,
        SAPP_KEYCODE_Y = 89,
        SAPP_KEYCODE_Z = 90,
        SAPP_KEYCODE_LEFT_BRACKET = 91,
        SAPP_KEYCODE_BACKSLASH = 92,
        SAPP_KEYCODE_RIGHT_BRACKET = 93,
        SAPP_KEYCODE_GRAVE_ACCENT = 96,
        SAPP_KEYCODE_WORLD_1 = 161,
        SAPP_KEYCODE_WORLD_2 = 162,
        SAPP_KEYCODE_ESCAPE = 256,
        SAPP_KEYCODE_ENTER = 257,
        SAPP_KEYCODE_TAB = 258,
        SAPP_KEYCODE_BACKSPACE = 259,
        SAPP_KEYCODE_INSERT = 260,
        SAPP_KEYCODE_DELETE = 261,
        SAPP_KEYCODE_RIGHT = 262,
        SAPP_KEYCODE_LEFT = 263,
        SAPP_KEYCODE_DOWN = 264,
        SAPP_KEYCODE_UP = 265,
        SAPP_KEYCODE_PAGE_UP = 266,
        SAPP_KEYCODE_PAGE_DOWN = 267,
        SAPP_KEYCODE_HOME = 268,
        SAPP_KEYCODE_END = 269,
        SAPP_KEYCODE_CAPS_LOCK = 280,
        SAPP_KEYCODE_SCROLL_LOCK = 281,
        SAPP_KEYCODE_NUM_LOCK = 282,
        SAPP_KEYCODE_PRINT_SCREEN = 283,
        SAPP_KEYCODE_PAUSE = 284,
        SAPP_KEYCODE_F1 = 290,
        SAPP_KEYCODE_F2 = 291,
        SAPP_KEYCODE_F3 = 292,
        SAPP_KEYCODE_F4 = 293,
        SAPP_KEYCODE_F5 = 294,
        SAPP_KEYCODE_F6 = 295,
        SAPP_KEYCODE_F7 = 296,
        SAPP_KEYCODE_F8 = 297,
        SAPP_KEYCODE_F9 = 298,
        SAPP_KEYCODE_F10 = 299,
        SAPP_KEYCODE_F11 = 300,
        SAPP_KEYCODE_F12 = 301,
        SAPP_KEYCODE_F13 = 302,
        SAPP_KEYCODE_F14 = 303,
        SAPP_KEYCODE_F15 = 304,
        SAPP_KEYCODE_F16 = 305,
        SAPP_KEYCODE_F17 = 306,
        SAPP_KEYCODE_F18 = 307,
        SAPP_KEYCODE_F19 = 308,
        SAPP_KEYCODE_F20 = 309,
        SAPP_KEYCODE_F21 = 310,
        SAPP_KEYCODE_F22 = 311,
        SAPP_KEYCODE_F23 = 312,
        SAPP_KEYCODE_F24 = 313,
        SAPP_KEYCODE_F25 = 314,
        SAPP_KEYCODE_KP_0 = 320,
        SAPP_KEYCODE_KP_1 = 321,
        SAPP_KEYCODE_KP_2 = 322,
        SAPP_KEYCODE_KP_3 = 323,
        SAPP_KEYCODE_KP_4 = 324,
        SAPP_KEYCODE_KP_5 = 325,
        SAPP_KEYCODE_KP_6 = 326,
        SAPP_KEYCODE_KP_7 = 327,
        SAPP_KEYCODE_KP_8 = 328,
        SAPP_KEYCODE_KP_9 = 329,
        SAPP_KEYCODE_KP_DECIMAL = 330,
        SAPP_KEYCODE_KP_DIVIDE = 331,
        SAPP_KEYCODE_KP_MULTIPLY = 332,
        SAPP_KEYCODE_KP_SUBTRACT = 333,
        SAPP_KEYCODE_KP_ADD = 334,
        SAPP_KEYCODE_KP_ENTER = 335,
        SAPP_KEYCODE_KP_EQUAL = 336,
        SAPP_KEYCODE_LEFT_SHIFT = 340,
        SAPP_KEYCODE_LEFT_CONTROL = 341,
        SAPP_KEYCODE_LEFT_ALT = 342,
        SAPP_KEYCODE_LEFT_SUPER = 343,
        SAPP_KEYCODE_RIGHT_SHIFT = 344,
        SAPP_KEYCODE_RIGHT_CONTROL = 345,
        SAPP_KEYCODE_RIGHT_ALT = 346,
        SAPP_KEYCODE_RIGHT_SUPER = 347,
        SAPP_KEYCODE_MENU = 348
    }

    [Flags]
    public enum SappMousebutton
    {
        SAPP_MOUSEBUTTON_LEFT = 0,
        SAPP_MOUSEBUTTON_RIGHT = 1,
        SAPP_MOUSEBUTTON_MIDDLE = 2,
        SAPP_MOUSEBUTTON_INVALID = 256
    }

    [Flags]
    public enum SAPP_MODIFIER
    {
        SAPP_MODIFIER_SHIFT = 1,
        SAPP_MODIFIER_CTRL = 2,
        SAPP_MODIFIER_ALT = 4,
        SAPP_MODIFIER_SUPER = 8,
        SAPP_MODIFIER_LMB = 256,
        SAPP_MODIFIER_RMB = 512,
        SAPP_MODIFIER_MMB = 1024
    }

    public enum SappHtml5FetchError
    {
        SAPP_HTML5FETCH_ERROR_NO_ERROR = 0,
        SAPP_HTML5FETCH_ERROR_BUFFER_TOO_SMALL = 1,
        SAPP_HTML5FETCH_ERROR_OTHER = 2
    }

    public unsafe partial class SappTouchpoint : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal ulong identifier;
            internal float pos_x;
            internal float pos_y;
            internal byte changed;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sapp_touchpoint@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappTouchpoint> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappTouchpoint>();

        protected bool __ownsNativeInstance;

        internal static SappTouchpoint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SappTouchpoint(native.ToPointer(), skipVTables);
        }

        internal static SappTouchpoint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SappTouchpoint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SappTouchpoint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SappTouchpoint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SappTouchpoint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SappTouchpoint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SappTouchpoint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappTouchpoint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SappTouchpoint(global::Sokol.SappTouchpoint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappTouchpoint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SappTouchpoint.__Internal*) __Instance) = *((global::Sokol.SappTouchpoint.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Identifier
        {
            get
            {
                return ((__Internal*)__Instance)->identifier;
            }

            set
            {
                ((__Internal*)__Instance)->identifier = value;
            }
        }

        public float PosX
        {
            get
            {
                return ((__Internal*)__Instance)->pos_x;
            }

            set
            {
                ((__Internal*)__Instance)->pos_x = value;
            }
        }

        public float PosY
        {
            get
            {
                return ((__Internal*)__Instance)->pos_y;
            }

            set
            {
                ((__Internal*)__Instance)->pos_y = value;
            }
        }

        public bool Changed
        {
            get
            {
                return ((__Internal*)__Instance)->changed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->changed = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class SappEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 272)]
        public partial struct __Internal
        {
            internal ulong frame_count;
            internal global::Sokol.SappEventType type;
            internal global::Sokol.SappKeycode key_code;
            internal uint char_code;
            internal byte key_repeat;
            internal uint modifiers;
            internal global::Sokol.SappMousebutton mouse_button;
            internal float mouse_x;
            internal float mouse_y;
            internal float mouse_dx;
            internal float mouse_dy;
            internal float scroll_x;
            internal float scroll_y;
            internal int num_touches;
            internal fixed byte touchesPadding[4];
            internal fixed byte touches[192];
            internal int window_width;
            internal int window_height;
            internal int framebuffer_width;
            internal int framebuffer_height;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sapp_event@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappEvent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappEvent>();

        protected bool __ownsNativeInstance;

        internal static SappEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SappEvent(native.ToPointer(), skipVTables);
        }

        internal static SappEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SappEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SappEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SappEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SappEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SappEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SappEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappEvent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SappEvent(global::Sokol.SappEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappEvent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SappEvent.__Internal*) __Instance) = *((global::Sokol.SappEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong FrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->frame_count;
            }

            set
            {
                ((__Internal*)__Instance)->frame_count = value;
            }
        }

        public global::Sokol.SappEventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public global::Sokol.SappKeycode KeyCode
        {
            get
            {
                return ((__Internal*)__Instance)->key_code;
            }

            set
            {
                ((__Internal*)__Instance)->key_code = value;
            }
        }

        public uint CharCode
        {
            get
            {
                return ((__Internal*)__Instance)->char_code;
            }

            set
            {
                ((__Internal*)__Instance)->char_code = value;
            }
        }

        public bool KeyRepeat
        {
            get
            {
                return ((__Internal*)__Instance)->key_repeat != 0;
            }

            set
            {
                ((__Internal*)__Instance)->key_repeat = (byte) (value ? 1 : 0);
            }
        }

        public uint Modifiers
        {
            get
            {
                return ((__Internal*)__Instance)->modifiers;
            }

            set
            {
                ((__Internal*)__Instance)->modifiers = value;
            }
        }

        public global::Sokol.SappMousebutton MouseButton
        {
            get
            {
                return ((__Internal*)__Instance)->mouse_button;
            }

            set
            {
                ((__Internal*)__Instance)->mouse_button = value;
            }
        }

        public float MouseX
        {
            get
            {
                return ((__Internal*)__Instance)->mouse_x;
            }

            set
            {
                ((__Internal*)__Instance)->mouse_x = value;
            }
        }

        public float MouseY
        {
            get
            {
                return ((__Internal*)__Instance)->mouse_y;
            }

            set
            {
                ((__Internal*)__Instance)->mouse_y = value;
            }
        }

        public float MouseDx
        {
            get
            {
                return ((__Internal*)__Instance)->mouse_dx;
            }

            set
            {
                ((__Internal*)__Instance)->mouse_dx = value;
            }
        }

        public float MouseDy
        {
            get
            {
                return ((__Internal*)__Instance)->mouse_dy;
            }

            set
            {
                ((__Internal*)__Instance)->mouse_dy = value;
            }
        }

        public float ScrollX
        {
            get
            {
                return ((__Internal*)__Instance)->scroll_x;
            }

            set
            {
                ((__Internal*)__Instance)->scroll_x = value;
            }
        }

        public float ScrollY
        {
            get
            {
                return ((__Internal*)__Instance)->scroll_y;
            }

            set
            {
                ((__Internal*)__Instance)->scroll_y = value;
            }
        }

        public int NumTouches
        {
            get
            {
                return ((__Internal*)__Instance)->num_touches;
            }

            set
            {
                ((__Internal*)__Instance)->num_touches = value;
            }
        }

        public global::Sokol.SappTouchpoint[] Touches
        {
            get
            {
                global::Sokol.SappTouchpoint[] __value = null;
                if (((__Internal*)__Instance)->touches != null)
                {
                    __value = new global::Sokol.SappTouchpoint[8];
                    for (int i = 0; i < 8; i++)
                        __value[i] = global::Sokol.SappTouchpoint.__GetOrCreateInstance((IntPtr)((global::Sokol.SappTouchpoint.__Internal*)&(((__Internal*)__Instance)->touches[i * sizeof(global::Sokol.SappTouchpoint.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 8)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 8; i++)
                        *(global::Sokol.SappTouchpoint.__Internal*) &((__Internal*)__Instance)->touches[i * sizeof(global::Sokol.SappTouchpoint.__Internal)] = *(global::Sokol.SappTouchpoint.__Internal*)value[i].__Instance;
                }
            }
        }

        public int WindowWidth
        {
            get
            {
                return ((__Internal*)__Instance)->window_width;
            }

            set
            {
                ((__Internal*)__Instance)->window_width = value;
            }
        }

        public int WindowHeight
        {
            get
            {
                return ((__Internal*)__Instance)->window_height;
            }

            set
            {
                ((__Internal*)__Instance)->window_height = value;
            }
        }

        public int FramebufferWidth
        {
            get
            {
                return ((__Internal*)__Instance)->framebuffer_width;
            }

            set
            {
                ((__Internal*)__Instance)->framebuffer_width = value;
            }
        }

        public int FramebufferHeight
        {
            get
            {
                return ((__Internal*)__Instance)->framebuffer_height;
            }

            set
            {
                ((__Internal*)__Instance)->framebuffer_height = value;
            }
        }
    }

    public unsafe partial class SappRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr ptr;
            internal ulong size;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sapp_range@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappRange>();

        protected bool __ownsNativeInstance;

        internal static SappRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SappRange(native.ToPointer(), skipVTables);
        }

        internal static SappRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SappRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SappRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SappRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SappRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SappRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SappRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SappRange(global::Sokol.SappRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SappRange.__Internal*) __Instance) = *((global::Sokol.SappRange.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Ptr
        {
            get
            {
                return ((__Internal*)__Instance)->ptr;
            }
        }

        public ulong Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }
    }

    public unsafe partial class SappImageDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal int width;
            internal int height;
            internal global::Sokol.SappRange.__Internal pixels;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sapp_image_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappImageDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappImageDesc>();

        protected bool __ownsNativeInstance;

        internal static SappImageDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SappImageDesc(native.ToPointer(), skipVTables);
        }

        internal static SappImageDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SappImageDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SappImageDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SappImageDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SappImageDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SappImageDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SappImageDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappImageDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SappImageDesc(global::Sokol.SappImageDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappImageDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SappImageDesc.__Internal*) __Instance) = *((global::Sokol.SappImageDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public global::Sokol.SappRange Pixels
        {
            get
            {
                return global::Sokol.SappRange.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pixels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pixels = *(global::Sokol.SappRange.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class SappIconDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 200)]
        public partial struct __Internal
        {
            internal byte sokol_default;
            internal fixed byte imagesPadding[7];
            internal fixed byte images[192];

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sapp_icon_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappIconDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappIconDesc>();

        protected bool __ownsNativeInstance;

        internal static SappIconDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SappIconDesc(native.ToPointer(), skipVTables);
        }

        internal static SappIconDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SappIconDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SappIconDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SappIconDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SappIconDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SappIconDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SappIconDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappIconDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SappIconDesc(global::Sokol.SappIconDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappIconDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SappIconDesc.__Internal*) __Instance) = *((global::Sokol.SappIconDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool SokolDefault
        {
            get
            {
                return ((__Internal*)__Instance)->sokol_default != 0;
            }

            set
            {
                ((__Internal*)__Instance)->sokol_default = (byte) (value ? 1 : 0);
            }
        }

        public global::Sokol.SappImageDesc[] Images
        {
            get
            {
                global::Sokol.SappImageDesc[] __value = null;
                if (((__Internal*)__Instance)->images != null)
                {
                    __value = new global::Sokol.SappImageDesc[8];
                    for (int i = 0; i < 8; i++)
                        __value[i] = global::Sokol.SappImageDesc.__GetOrCreateInstance((IntPtr)((global::Sokol.SappImageDesc.__Internal*)&(((__Internal*)__Instance)->images[i * sizeof(global::Sokol.SappImageDesc.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 8)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 8; i++)
                        *(global::Sokol.SappImageDesc.__Internal*) &((__Internal*)__Instance)->images[i * sizeof(global::Sokol.SappImageDesc.__Internal)] = *(global::Sokol.SappImageDesc.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class SappAllocator : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr alloc;
            internal __IntPtr free;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sapp_allocator@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappAllocator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappAllocator>();

        protected bool __ownsNativeInstance;

        internal static SappAllocator __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SappAllocator(native.ToPointer(), skipVTables);
        }

        internal static SappAllocator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SappAllocator)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SappAllocator __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SappAllocator(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SappAllocator(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SappAllocator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SappAllocator()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappAllocator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SappAllocator(global::Sokol.SappAllocator _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappAllocator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SappAllocator.__Internal*) __Instance) = *((global::Sokol.SappAllocator.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.Delegates.Func___IntPtr_ulong___IntPtr Alloc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->alloc;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr_ulong___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr_ulong___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->alloc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr___IntPtr Free
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->free;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->free = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class SappDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 400)]
        public partial struct __Internal
        {
            internal __IntPtr init_cb;
            internal __IntPtr frame_cb;
            internal __IntPtr cleanup_cb;
            internal __IntPtr event_cb;
            internal __IntPtr fail_cb;
            internal __IntPtr user_data;
            internal __IntPtr init_userdata_cb;
            internal __IntPtr frame_userdata_cb;
            internal __IntPtr cleanup_userdata_cb;
            internal __IntPtr event_userdata_cb;
            internal __IntPtr fail_userdata_cb;
            internal int width;
            internal int height;
            internal int sample_count;
            internal int swap_interval;
            internal byte high_dpi;
            internal byte fullscreen;
            internal byte alpha;
            internal __IntPtr window_title;
            internal byte user_cursor;
            internal byte enable_clipboard;
            internal int clipboard_size;
            internal byte enable_dragndrop;
            internal int max_dropped_files;
            internal int max_dropped_file_path_length;
            internal global::Sokol.SappIconDesc.__Internal icon;
            internal global::Sokol.SappAllocator.__Internal allocator;
            internal byte gl_force_gles2;
            internal int gl_major_version;
            internal int gl_minor_version;
            internal byte win32_console_utf8;
            internal byte win32_console_create;
            internal byte win32_console_attach;
            internal __IntPtr html5_canvas_name;
            internal byte html5_canvas_resize;
            internal byte html5_preserve_drawing_buffer;
            internal byte html5_premultiplied_alpha;
            internal byte html5_ask_leave_site;
            internal byte ios_keyboard_resizes_canvas;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sapp_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappDesc>();

        private bool __window_title_OwnsNativeMemory = false;
        private bool __html5_canvas_name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SappDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SappDesc(native.ToPointer(), skipVTables);
        }

        internal static SappDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SappDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SappDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SappDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SappDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SappDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SappDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SappDesc(global::Sokol.SappDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SappDesc.__Internal*) __Instance) = *((global::Sokol.SappDesc.__Internal*) _0.__Instance);
            if (_0.__window_title_OwnsNativeMemory)
                this.WindowTitle = _0.WindowTitle;
            if (_0.__html5_canvas_name_OwnsNativeMemory)
                this.Html5CanvasName = _0.Html5CanvasName;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__window_title_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->window_title);
            if (__html5_canvas_name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->html5_canvas_name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.Delegates.Action_ InitCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->init_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_));
            }

            set
            {
                ((__Internal*)__Instance)->init_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_ FrameCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->frame_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_));
            }

            set
            {
                ((__Internal*)__Instance)->frame_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_ CleanupCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->cleanup_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_));
            }

            set
            {
                ((__Internal*)__Instance)->cleanup_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr EventCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->event_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->event_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_string8 FailCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->fail_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_string8));
            }

            set
            {
                ((__Internal*)__Instance)->fail_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        public global::Sokol.Delegates.Action___IntPtr InitUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->init_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->init_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr FrameUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->frame_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->frame_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr CleanupUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->cleanup_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->cleanup_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr___IntPtr EventUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->event_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->event_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_string8___IntPtr FailUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->fail_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_string8___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_string8___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->fail_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public int SampleCount
        {
            get
            {
                return ((__Internal*)__Instance)->sample_count;
            }

            set
            {
                ((__Internal*)__Instance)->sample_count = value;
            }
        }

        public int SwapInterval
        {
            get
            {
                return ((__Internal*)__Instance)->swap_interval;
            }

            set
            {
                ((__Internal*)__Instance)->swap_interval = value;
            }
        }

        public bool HighDpi
        {
            get
            {
                return ((__Internal*)__Instance)->high_dpi != 0;
            }

            set
            {
                ((__Internal*)__Instance)->high_dpi = (byte) (value ? 1 : 0);
            }
        }

        public bool Fullscreen
        {
            get
            {
                return ((__Internal*)__Instance)->fullscreen != 0;
            }

            set
            {
                ((__Internal*)__Instance)->fullscreen = (byte) (value ? 1 : 0);
            }
        }

        public bool Alpha
        {
            get
            {
                return ((__Internal*)__Instance)->alpha != 0;
            }

            set
            {
                ((__Internal*)__Instance)->alpha = (byte) (value ? 1 : 0);
            }
        }

        public string WindowTitle
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->window_title);
            }

            set
            {
                if (__window_title_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->window_title);
                __window_title_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->window_title = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->window_title = (__IntPtr) __bytePtr0;
            }
        }

        public bool UserCursor
        {
            get
            {
                return ((__Internal*)__Instance)->user_cursor != 0;
            }

            set
            {
                ((__Internal*)__Instance)->user_cursor = (byte) (value ? 1 : 0);
            }
        }

        public bool EnableClipboard
        {
            get
            {
                return ((__Internal*)__Instance)->enable_clipboard != 0;
            }

            set
            {
                ((__Internal*)__Instance)->enable_clipboard = (byte) (value ? 1 : 0);
            }
        }

        public int ClipboardSize
        {
            get
            {
                return ((__Internal*)__Instance)->clipboard_size;
            }

            set
            {
                ((__Internal*)__Instance)->clipboard_size = value;
            }
        }

        public bool EnableDragndrop
        {
            get
            {
                return ((__Internal*)__Instance)->enable_dragndrop != 0;
            }

            set
            {
                ((__Internal*)__Instance)->enable_dragndrop = (byte) (value ? 1 : 0);
            }
        }

        public int MaxDroppedFiles
        {
            get
            {
                return ((__Internal*)__Instance)->max_dropped_files;
            }

            set
            {
                ((__Internal*)__Instance)->max_dropped_files = value;
            }
        }

        public int MaxDroppedFilePathLength
        {
            get
            {
                return ((__Internal*)__Instance)->max_dropped_file_path_length;
            }

            set
            {
                ((__Internal*)__Instance)->max_dropped_file_path_length = value;
            }
        }

        public global::Sokol.SappIconDesc Icon
        {
            get
            {
                return global::Sokol.SappIconDesc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->icon));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->icon = *(global::Sokol.SappIconDesc.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SappAllocator Allocator
        {
            get
            {
                return global::Sokol.SappAllocator.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->allocator));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->allocator = *(global::Sokol.SappAllocator.__Internal*) value.__Instance;
            }
        }

        public bool GlForceGles2
        {
            get
            {
                return ((__Internal*)__Instance)->gl_force_gles2 != 0;
            }

            set
            {
                ((__Internal*)__Instance)->gl_force_gles2 = (byte) (value ? 1 : 0);
            }
        }

        public int GlMajorVersion
        {
            get
            {
                return ((__Internal*)__Instance)->gl_major_version;
            }

            set
            {
                ((__Internal*)__Instance)->gl_major_version = value;
            }
        }

        public int GlMinorVersion
        {
            get
            {
                return ((__Internal*)__Instance)->gl_minor_version;
            }

            set
            {
                ((__Internal*)__Instance)->gl_minor_version = value;
            }
        }

        public bool Win32ConsoleUtf8
        {
            get
            {
                return ((__Internal*)__Instance)->win32_console_utf8 != 0;
            }

            set
            {
                ((__Internal*)__Instance)->win32_console_utf8 = (byte) (value ? 1 : 0);
            }
        }

        public bool Win32ConsoleCreate
        {
            get
            {
                return ((__Internal*)__Instance)->win32_console_create != 0;
            }

            set
            {
                ((__Internal*)__Instance)->win32_console_create = (byte) (value ? 1 : 0);
            }
        }

        public bool Win32ConsoleAttach
        {
            get
            {
                return ((__Internal*)__Instance)->win32_console_attach != 0;
            }

            set
            {
                ((__Internal*)__Instance)->win32_console_attach = (byte) (value ? 1 : 0);
            }
        }

        public string Html5CanvasName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->html5_canvas_name);
            }

            set
            {
                if (__html5_canvas_name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->html5_canvas_name);
                __html5_canvas_name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->html5_canvas_name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->html5_canvas_name = (__IntPtr) __bytePtr0;
            }
        }

        public bool Html5CanvasResize
        {
            get
            {
                return ((__Internal*)__Instance)->html5_canvas_resize != 0;
            }

            set
            {
                ((__Internal*)__Instance)->html5_canvas_resize = (byte) (value ? 1 : 0);
            }
        }

        public bool Html5PreserveDrawingBuffer
        {
            get
            {
                return ((__Internal*)__Instance)->html5_preserve_drawing_buffer != 0;
            }

            set
            {
                ((__Internal*)__Instance)->html5_preserve_drawing_buffer = (byte) (value ? 1 : 0);
            }
        }

        public bool Html5PremultipliedAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->html5_premultiplied_alpha != 0;
            }

            set
            {
                ((__Internal*)__Instance)->html5_premultiplied_alpha = (byte) (value ? 1 : 0);
            }
        }

        public bool Html5AskLeaveSite
        {
            get
            {
                return ((__Internal*)__Instance)->html5_ask_leave_site != 0;
            }

            set
            {
                ((__Internal*)__Instance)->html5_ask_leave_site = (byte) (value ? 1 : 0);
            }
        }

        public bool IosKeyboardResizesCanvas
        {
            get
            {
                return ((__Internal*)__Instance)->ios_keyboard_resizes_canvas != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ios_keyboard_resizes_canvas = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class SappHtml5FetchResponse : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal byte succeeded;
            internal global::Sokol.SappHtml5FetchError error_code;
            internal int file_index;
            internal uint fetched_size;
            internal __IntPtr buffer_ptr;
            internal uint buffer_size;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sapp_html5_fetch_response@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappHtml5FetchResponse> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappHtml5FetchResponse>();

        protected bool __ownsNativeInstance;

        internal static SappHtml5FetchResponse __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SappHtml5FetchResponse(native.ToPointer(), skipVTables);
        }

        internal static SappHtml5FetchResponse __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SappHtml5FetchResponse)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SappHtml5FetchResponse __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SappHtml5FetchResponse(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SappHtml5FetchResponse(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SappHtml5FetchResponse(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SappHtml5FetchResponse()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappHtml5FetchResponse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SappHtml5FetchResponse(global::Sokol.SappHtml5FetchResponse _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappHtml5FetchResponse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SappHtml5FetchResponse.__Internal*) __Instance) = *((global::Sokol.SappHtml5FetchResponse.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Succeeded
        {
            get
            {
                return ((__Internal*)__Instance)->succeeded != 0;
            }

            set
            {
                ((__Internal*)__Instance)->succeeded = (byte) (value ? 1 : 0);
            }
        }

        public global::Sokol.SappHtml5FetchError ErrorCode
        {
            get
            {
                return ((__Internal*)__Instance)->error_code;
            }

            set
            {
                ((__Internal*)__Instance)->error_code = value;
            }
        }

        public int FileIndex
        {
            get
            {
                return ((__Internal*)__Instance)->file_index;
            }

            set
            {
                ((__Internal*)__Instance)->file_index = value;
            }
        }

        public uint FetchedSize
        {
            get
            {
                return ((__Internal*)__Instance)->fetched_size;
            }

            set
            {
                ((__Internal*)__Instance)->fetched_size = value;
            }
        }

        public __IntPtr BufferPtr
        {
            get
            {
                return ((__Internal*)__Instance)->buffer_ptr;
            }

            set
            {
                ((__Internal*)__Instance)->buffer_ptr = (__IntPtr) value;
            }
        }

        public uint BufferSize
        {
            get
            {
                return ((__Internal*)__Instance)->buffer_size;
            }

            set
            {
                ((__Internal*)__Instance)->buffer_size = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class SappHtml5FetchRequest : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal int dropped_file_index;
            internal __IntPtr callback;
            internal __IntPtr buffer_ptr;
            internal uint buffer_size;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sapp_html5_fetch_request@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappHtml5FetchRequest> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SappHtml5FetchRequest>();

        protected bool __ownsNativeInstance;

        internal static SappHtml5FetchRequest __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SappHtml5FetchRequest(native.ToPointer(), skipVTables);
        }

        internal static SappHtml5FetchRequest __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SappHtml5FetchRequest)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SappHtml5FetchRequest __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SappHtml5FetchRequest(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SappHtml5FetchRequest(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SappHtml5FetchRequest(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SappHtml5FetchRequest()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappHtml5FetchRequest.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SappHtml5FetchRequest(global::Sokol.SappHtml5FetchRequest _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SappHtml5FetchRequest.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SappHtml5FetchRequest.__Internal*) __Instance) = *((global::Sokol.SappHtml5FetchRequest.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int DroppedFileIndex
        {
            get
            {
                return ((__Internal*)__Instance)->dropped_file_index;
            }

            set
            {
                ((__Internal*)__Instance)->dropped_file_index = value;
            }
        }

        public global::Sokol.Delegates.Action___IntPtr Callback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->callback;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr BufferPtr
        {
            get
            {
                return ((__Internal*)__Instance)->buffer_ptr;
            }

            set
            {
                ((__Internal*)__Instance)->buffer_ptr = (__IntPtr) value;
            }
        }

        public uint BufferSize
        {
            get
            {
                return ((__Internal*)__Instance)->buffer_size;
            }

            set
            {
                ((__Internal*)__Instance)->buffer_size = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class sokol_app
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sokol_main", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SokolMain(__IntPtr @return, int argc, [MarshalAs(UnmanagedType.LPArray)] string[] argv);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_isvalid", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SappIsvalid();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SappWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_widthf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float SappWidthf();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SappHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_heightf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float SappHeightf();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_color_format", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SappColorFormat();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_depth_format", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SappDepthFormat();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_sample_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SappSampleCount();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_high_dpi", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SappHighDpi();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_dpi_scale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float SappDpiScale();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_show_keyboard", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappShowKeyboard(bool show);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_keyboard_shown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SappKeyboardShown();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_is_fullscreen", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SappIsFullscreen();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_toggle_fullscreen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappToggleFullscreen();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_show_mouse", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappShowMouse(bool show);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_mouse_shown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SappMouseShown();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_lock_mouse", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappLockMouse(bool @lock);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_mouse_locked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SappMouseLocked();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_userdata", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappUserdata();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_query_desc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappQueryDesc(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_request_quit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappRequestQuit();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_cancel_quit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappCancelQuit();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_quit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappQuit();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_consume_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappConsumeEvent();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_frame_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SappFrameCount();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_frame_duration", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double SappFrameDuration();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_set_clipboard_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappSetClipboardString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_get_clipboard_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappGetClipboardString();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_set_window_title", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappSetWindowTitle([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_set_icon", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappSetIcon(__IntPtr icon_desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_get_num_dropped_files", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SappGetNumDroppedFiles();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_get_dropped_file_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappGetDroppedFilePath(int index);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_gles2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SappGles2();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_html5_ask_leave_site", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappHtml5AskLeaveSite(bool ask);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_html5_get_dropped_file_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SappHtml5GetDroppedFileSize(int index);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_html5_fetch_dropped_file", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappHtml5FetchDroppedFile(__IntPtr request);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_metal_get_device", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappMetalGetDevice();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_metal_get_renderpass_descriptor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappMetalGetRenderpassDescriptor();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_metal_get_drawable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappMetalGetDrawable();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_macos_get_window", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappMacosGetWindow();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_ios_get_window", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappIosGetWindow();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_d3d11_get_device", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappD3d11GetDevice();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_d3d11_get_device_context", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappD3d11GetDeviceContext();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_d3d11_get_swap_chain", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappD3d11GetSwapChain();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_d3d11_get_render_target_view", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappD3d11GetRenderTargetView();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_d3d11_get_depth_stencil_view", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappD3d11GetDepthStencilView();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_win32_get_hwnd", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappWin32GetHwnd();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_wgpu_get_device", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappWgpuGetDevice();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_wgpu_get_render_view", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappWgpuGetRenderView();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_wgpu_get_resolve_view", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappWgpuGetResolveView();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_wgpu_get_depth_stencil_view", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappWgpuGetDepthStencilView();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_android_get_native_activity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SappAndroidGetNativeActivity();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sapp_run", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SappRun(__IntPtr desc);
        }

        public static global::Sokol.SappDesc SokolMain(int argc, string[] argv)
        {
            var __ret = new global::Sokol.SappDesc.__Internal();
            __Internal.SokolMain(new IntPtr(&__ret), argc, argv);
            return global::Sokol.SappDesc.__CreateInstance(__ret);
        }

        public static bool SappIsvalid()
        {
            var __ret = __Internal.SappIsvalid();
            return __ret;
        }

        public static int SappWidth()
        {
            var __ret = __Internal.SappWidth();
            return __ret;
        }

        public static float SappWidthf()
        {
            var __ret = __Internal.SappWidthf();
            return __ret;
        }

        public static int SappHeight()
        {
            var __ret = __Internal.SappHeight();
            return __ret;
        }

        public static float SappHeightf()
        {
            var __ret = __Internal.SappHeightf();
            return __ret;
        }

        public static int SappColorFormat()
        {
            var __ret = __Internal.SappColorFormat();
            return __ret;
        }

        public static int SappDepthFormat()
        {
            var __ret = __Internal.SappDepthFormat();
            return __ret;
        }

        public static int SappSampleCount()
        {
            var __ret = __Internal.SappSampleCount();
            return __ret;
        }

        public static bool SappHighDpi()
        {
            var __ret = __Internal.SappHighDpi();
            return __ret;
        }

        public static float SappDpiScale()
        {
            var __ret = __Internal.SappDpiScale();
            return __ret;
        }

        public static void SappShowKeyboard(bool show)
        {
            __Internal.SappShowKeyboard(show);
        }

        public static bool SappKeyboardShown()
        {
            var __ret = __Internal.SappKeyboardShown();
            return __ret;
        }

        public static bool SappIsFullscreen()
        {
            var __ret = __Internal.SappIsFullscreen();
            return __ret;
        }

        public static void SappToggleFullscreen()
        {
            __Internal.SappToggleFullscreen();
        }

        public static void SappShowMouse(bool show)
        {
            __Internal.SappShowMouse(show);
        }

        public static bool SappMouseShown()
        {
            var __ret = __Internal.SappMouseShown();
            return __ret;
        }

        public static void SappLockMouse(bool @lock)
        {
            __Internal.SappLockMouse(@lock);
        }

        public static bool SappMouseLocked()
        {
            var __ret = __Internal.SappMouseLocked();
            return __ret;
        }

        public static __IntPtr SappUserdata()
        {
            var __ret = __Internal.SappUserdata();
            return __ret;
        }

        public static global::Sokol.SappDesc SappQueryDesc()
        {
            var __ret = new global::Sokol.SappDesc.__Internal();
            __Internal.SappQueryDesc(new IntPtr(&__ret));
            return global::Sokol.SappDesc.__CreateInstance(__ret);
        }

        public static void SappRequestQuit()
        {
            __Internal.SappRequestQuit();
        }

        public static void SappCancelQuit()
        {
            __Internal.SappCancelQuit();
        }

        public static void SappQuit()
        {
            __Internal.SappQuit();
        }

        public static void SappConsumeEvent()
        {
            __Internal.SappConsumeEvent();
        }

        public static ulong SappFrameCount()
        {
            var __ret = __Internal.SappFrameCount();
            return __ret;
        }

        public static double SappFrameDuration()
        {
            var __ret = __Internal.SappFrameDuration();
            return __ret;
        }

        public static void SappSetClipboardString(string str)
        {
            __Internal.SappSetClipboardString(str);
        }

        public static string SappGetClipboardString()
        {
            var __ret = __Internal.SappGetClipboardString();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void SappSetWindowTitle(string str)
        {
            __Internal.SappSetWindowTitle(str);
        }

        public static void SappSetIcon(global::Sokol.SappIconDesc icon_desc)
        {
            var __arg0 = icon_desc is null ? __IntPtr.Zero : icon_desc.__Instance;
            __Internal.SappSetIcon(__arg0);
        }

        public static int SappGetNumDroppedFiles()
        {
            var __ret = __Internal.SappGetNumDroppedFiles();
            return __ret;
        }

        public static string SappGetDroppedFilePath(int index)
        {
            var __ret = __Internal.SappGetDroppedFilePath(index);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static bool SappGles2()
        {
            var __ret = __Internal.SappGles2();
            return __ret;
        }

        public static void SappHtml5AskLeaveSite(bool ask)
        {
            __Internal.SappHtml5AskLeaveSite(ask);
        }

        public static uint SappHtml5GetDroppedFileSize(int index)
        {
            var __ret = __Internal.SappHtml5GetDroppedFileSize(index);
            return __ret;
        }

        public static void SappHtml5FetchDroppedFile(global::Sokol.SappHtml5FetchRequest request)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__Instance;
            __Internal.SappHtml5FetchDroppedFile(__arg0);
        }

        public static __IntPtr SappMetalGetDevice()
        {
            var __ret = __Internal.SappMetalGetDevice();
            return __ret;
        }

        public static __IntPtr SappMetalGetRenderpassDescriptor()
        {
            var __ret = __Internal.SappMetalGetRenderpassDescriptor();
            return __ret;
        }

        public static __IntPtr SappMetalGetDrawable()
        {
            var __ret = __Internal.SappMetalGetDrawable();
            return __ret;
        }

        public static __IntPtr SappMacosGetWindow()
        {
            var __ret = __Internal.SappMacosGetWindow();
            return __ret;
        }

        public static __IntPtr SappIosGetWindow()
        {
            var __ret = __Internal.SappIosGetWindow();
            return __ret;
        }

        public static __IntPtr SappD3d11GetDevice()
        {
            var __ret = __Internal.SappD3d11GetDevice();
            return __ret;
        }

        public static __IntPtr SappD3d11GetDeviceContext()
        {
            var __ret = __Internal.SappD3d11GetDeviceContext();
            return __ret;
        }

        public static __IntPtr SappD3d11GetSwapChain()
        {
            var __ret = __Internal.SappD3d11GetSwapChain();
            return __ret;
        }

        public static __IntPtr SappD3d11GetRenderTargetView()
        {
            var __ret = __Internal.SappD3d11GetRenderTargetView();
            return __ret;
        }

        public static __IntPtr SappD3d11GetDepthStencilView()
        {
            var __ret = __Internal.SappD3d11GetDepthStencilView();
            return __ret;
        }

        public static __IntPtr SappWin32GetHwnd()
        {
            var __ret = __Internal.SappWin32GetHwnd();
            return __ret;
        }

        public static __IntPtr SappWgpuGetDevice()
        {
            var __ret = __Internal.SappWgpuGetDevice();
            return __ret;
        }

        public static __IntPtr SappWgpuGetRenderView()
        {
            var __ret = __Internal.SappWgpuGetRenderView();
            return __ret;
        }

        public static __IntPtr SappWgpuGetResolveView()
        {
            var __ret = __Internal.SappWgpuGetResolveView();
            return __ret;
        }

        public static __IntPtr SappWgpuGetDepthStencilView()
        {
            var __ret = __Internal.SappWgpuGetDepthStencilView();
            return __ret;
        }

        public static __IntPtr SappAndroidGetNativeActivity()
        {
            var __ret = __Internal.SappAndroidGetNativeActivity();
            return __ret;
        }

        public static void SappRun(global::Sokol.SappDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            __Internal.SappRun(__arg0);
        }
    }

    public enum SG
    {
        SG_INVALID_ID = 0,
        SG_NUM_SHADER_STAGES = 2,
        SG_NUM_INFLIGHT_FRAMES = 2,
        SG_MAX_COLOR_ATTACHMENTS = 4,
        SG_MAX_SHADERSTAGE_BUFFERS = 8,
        SG_MAX_SHADERSTAGE_IMAGES = 12,
        SG_MAX_SHADERSTAGE_UBS = 4,
        SG_MAX_UB_MEMBERS = 16,
        SG_MAX_VERTEX_ATTRIBUTES = 16,
        SG_MAX_MIPMAPS = 16,
        SG_MAX_TEXTUREARRAY_LAYERS = 128
    }

    public enum SgBackend
    {
        SG_BACKEND_GLCORE33 = 0,
        SG_BACKEND_GLES2 = 1,
        SG_BACKEND_GLES3 = 2,
        SG_BACKEND_D3D11 = 3,
        SG_BACKEND_METAL_IOS = 4,
        SG_BACKEND_METAL_MACOS = 5,
        SG_BACKEND_METAL_SIMULATOR = 6,
        SG_BACKEND_WGPU = 7,
        SG_BACKEND_DUMMY = 8
    }

    public enum SgPixelFormat
    {
        SG_PIXELFORMAT_DEFAULT = 0,
        SG_PIXELFORMAT_NONE = 1,
        SG_PIXELFORMAT_R8 = 2,
        SG_PIXELFORMAT_R8SN = 3,
        SG_PIXELFORMAT_R8UI = 4,
        SG_PIXELFORMAT_R8SI = 5,
        SG_PIXELFORMAT_R16 = 6,
        SG_PIXELFORMAT_R16SN = 7,
        SG_PIXELFORMAT_R16UI = 8,
        SG_PIXELFORMAT_R16SI = 9,
        SG_PIXELFORMAT_R16F = 10,
        SG_PIXELFORMAT_RG8 = 11,
        SG_PIXELFORMAT_RG8SN = 12,
        SG_PIXELFORMAT_RG8UI = 13,
        SG_PIXELFORMAT_RG8SI = 14,
        SG_PIXELFORMAT_R32UI = 15,
        SG_PIXELFORMAT_R32SI = 16,
        SG_PIXELFORMAT_R32F = 17,
        SG_PIXELFORMAT_RG16 = 18,
        SG_PIXELFORMAT_RG16SN = 19,
        SG_PIXELFORMAT_RG16UI = 20,
        SG_PIXELFORMAT_RG16SI = 21,
        SG_PIXELFORMAT_RG16F = 22,
        SG_PIXELFORMAT_RGBA8 = 23,
        SG_PIXELFORMAT_RGBA8SN = 24,
        SG_PIXELFORMAT_RGBA8UI = 25,
        SG_PIXELFORMAT_RGBA8SI = 26,
        SG_PIXELFORMAT_BGRA8 = 27,
        SG_PIXELFORMAT_RGB10A2 = 28,
        SG_PIXELFORMAT_RG11B10F = 29,
        SG_PIXELFORMAT_RG32UI = 30,
        SG_PIXELFORMAT_RG32SI = 31,
        SG_PIXELFORMAT_RG32F = 32,
        SG_PIXELFORMAT_RGBA16 = 33,
        SG_PIXELFORMAT_RGBA16SN = 34,
        SG_PIXELFORMAT_RGBA16UI = 35,
        SG_PIXELFORMAT_RGBA16SI = 36,
        SG_PIXELFORMAT_RGBA16F = 37,
        SG_PIXELFORMAT_RGBA32UI = 38,
        SG_PIXELFORMAT_RGBA32SI = 39,
        SG_PIXELFORMAT_RGBA32F = 40,
        SG_PIXELFORMAT_DEPTH = 41,
        SG_PIXELFORMAT_DEPTH_STENCIL = 42,
        SG_PIXELFORMAT_BC1RGBA = 43,
        SG_PIXELFORMAT_BC2RGBA = 44,
        SG_PIXELFORMAT_BC3RGBA = 45,
        SG_PIXELFORMAT_BC4R = 46,
        SG_PIXELFORMAT_BC4RSN = 47,
        SG_PIXELFORMAT_BC5RG = 48,
        SG_PIXELFORMAT_BC5RGSN = 49,
        SG_PIXELFORMAT_BC6H_RGBF = 50,
        SG_PIXELFORMAT_BC6H_RGBUF = 51,
        SG_PIXELFORMAT_BC7RGBA = 52,
        SG_PIXELFORMAT_PVRTC_RGB_2BPP = 53,
        SG_PIXELFORMAT_PVRTC_RGB_4BPP = 54,
        SG_PIXELFORMAT_PVRTC_RGBA_2BPP = 55,
        SG_PIXELFORMAT_PVRTC_RGBA_4BPP = 56,
        SG_PIXELFORMAT_ETC2RGB8 = 57,
        SG_PIXELFORMAT_ETC2RGB8A1 = 58,
        SG_PIXELFORMAT_ETC2RGBA8 = 59,
        SG_PIXELFORMAT_ETC2RG11 = 60,
        SG_PIXELFORMAT_ETC2RG11SN = 61,
        SG_PIXELFORMAT_NUM = 62,
        SG_PIXELFORMAT_FORCE_U32 = 2147483647
    }

    public enum SgResourceState
    {
        SG_RESOURCESTATE_INITIAL = 0,
        SG_RESOURCESTATE_ALLOC = 1,
        SG_RESOURCESTATE_VALID = 2,
        SG_RESOURCESTATE_FAILED = 3,
        SG_RESOURCESTATE_INVALID = 4,
        SG_RESOURCESTATE_FORCE_U32 = 2147483647
    }

    public enum SgUsage
    {
        SG_USAGE_DEFAULT = 0,
        SG_USAGE_IMMUTABLE = 1,
        SG_USAGE_DYNAMIC = 2,
        SG_USAGE_STREAM = 3,
        SG_USAGE_NUM = 4,
        SG_USAGE_FORCE_U32 = 2147483647
    }

    public enum SgBufferType
    {
        SG_BUFFERTYPE_DEFAULT = 0,
        SG_BUFFERTYPE_VERTEXBUFFER = 1,
        SG_BUFFERTYPE_INDEXBUFFER = 2,
        SG_BUFFERTYPE_NUM = 3,
        SG_BUFFERTYPE_FORCE_U32 = 2147483647
    }

    public enum SgIndexType
    {
        SG_INDEXTYPE_DEFAULT = 0,
        SG_INDEXTYPE_NONE = 1,
        SG_INDEXTYPE_UINT16 = 2,
        SG_INDEXTYPE_UINT32 = 3,
        SG_INDEXTYPE_NUM = 4,
        SG_INDEXTYPE_FORCE_U32 = 2147483647
    }

    public enum SgImageType
    {
        SG_IMAGETYPE_DEFAULT = 0,
        SG_IMAGETYPE_2D = 1,
        SG_IMAGETYPE_CUBE = 2,
        SG_IMAGETYPE_3D = 3,
        SG_IMAGETYPE_ARRAY = 4,
        SG_IMAGETYPE_NUM = 5,
        SG_IMAGETYPE_FORCE_U32 = 2147483647
    }

    public enum SgSamplerType
    {
        SG_SAMPLERTYPE_DEFAULT = 0,
        SG_SAMPLERTYPE_FLOAT = 1,
        SG_SAMPLERTYPE_SINT = 2,
        SG_SAMPLERTYPE_UINT = 3
    }

    public enum SgCubeFace
    {
        SG_CUBEFACE_POS_X = 0,
        SG_CUBEFACE_NEG_X = 1,
        SG_CUBEFACE_POS_Y = 2,
        SG_CUBEFACE_NEG_Y = 3,
        SG_CUBEFACE_POS_Z = 4,
        SG_CUBEFACE_NEG_Z = 5,
        SG_CUBEFACE_NUM = 6,
        SG_CUBEFACE_FORCE_U32 = 2147483647
    }

    public enum SgShaderStage
    {
        SG_SHADERSTAGE_VS = 0,
        SG_SHADERSTAGE_FS = 1,
        SG_SHADERSTAGE_FORCE_U32 = 2147483647
    }

    public enum SgPrimitiveType
    {
        SG_PRIMITIVETYPE_DEFAULT = 0,
        SG_PRIMITIVETYPE_POINTS = 1,
        SG_PRIMITIVETYPE_LINES = 2,
        SG_PRIMITIVETYPE_LINE_STRIP = 3,
        SG_PRIMITIVETYPE_TRIANGLES = 4,
        SG_PRIMITIVETYPE_TRIANGLE_STRIP = 5,
        SG_PRIMITIVETYPE_NUM = 6,
        SG_PRIMITIVETYPE_FORCE_U32 = 2147483647
    }

    public enum SgFilter
    {
        SG_FILTER_DEFAULT = 0,
        SG_FILTER_NEAREST = 1,
        SG_FILTER_LINEAR = 2,
        SG_FILTER_NEAREST_MIPMAP_NEAREST = 3,
        SG_FILTER_NEAREST_MIPMAP_LINEAR = 4,
        SG_FILTER_LINEAR_MIPMAP_NEAREST = 5,
        SG_FILTER_LINEAR_MIPMAP_LINEAR = 6,
        SG_FILTER_NUM = 7,
        SG_FILTER_FORCE_U32 = 2147483647
    }

    public enum SgWrap
    {
        SG_WRAP_DEFAULT = 0,
        SG_WRAP_REPEAT = 1,
        SG_WRAP_CLAMP_TO_EDGE = 2,
        SG_WRAP_CLAMP_TO_BORDER = 3,
        SG_WRAP_MIRRORED_REPEAT = 4,
        SG_WRAP_NUM = 5,
        SG_WRAP_FORCE_U32 = 2147483647
    }

    public enum SgBorderColor
    {
        SG_BORDERCOLOR_DEFAULT = 0,
        SG_BORDERCOLOR_TRANSPARENT_BLACK = 1,
        SG_BORDERCOLOR_OPAQUE_BLACK = 2,
        SG_BORDERCOLOR_OPAQUE_WHITE = 3,
        SG_BORDERCOLOR_NUM = 4,
        SG_BORDERCOLOR_FORCE_U32 = 2147483647
    }

    public enum SgVertexFormat
    {
        SG_VERTEXFORMAT_INVALID = 0,
        SG_VERTEXFORMAT_FLOAT = 1,
        SG_VERTEXFORMAT_FLOAT2 = 2,
        SG_VERTEXFORMAT_FLOAT3 = 3,
        SG_VERTEXFORMAT_FLOAT4 = 4,
        SG_VERTEXFORMAT_BYTE4 = 5,
        SG_VERTEXFORMAT_BYTE4N = 6,
        SG_VERTEXFORMAT_UBYTE4 = 7,
        SG_VERTEXFORMAT_UBYTE4N = 8,
        SG_VERTEXFORMAT_SHORT2 = 9,
        SG_VERTEXFORMAT_SHORT2N = 10,
        SG_VERTEXFORMAT_USHORT2N = 11,
        SG_VERTEXFORMAT_SHORT4 = 12,
        SG_VERTEXFORMAT_SHORT4N = 13,
        SG_VERTEXFORMAT_USHORT4N = 14,
        SG_VERTEXFORMAT_UINT10N2 = 15,
        SG_VERTEXFORMAT_NUM = 16,
        SG_VERTEXFORMAT_FORCE_U32 = 2147483647
    }

    public enum SgVertexStep
    {
        SG_VERTEXSTEP_DEFAULT = 0,
        SG_VERTEXSTEP_PER_VERTEX = 1,
        SG_VERTEXSTEP_PER_INSTANCE = 2,
        SG_VERTEXSTEP_NUM = 3,
        SG_VERTEXSTEP_FORCE_U32 = 2147483647
    }

    public enum SgUniformType
    {
        SG_UNIFORMTYPE_INVALID = 0,
        SG_UNIFORMTYPE_FLOAT = 1,
        SG_UNIFORMTYPE_FLOAT2 = 2,
        SG_UNIFORMTYPE_FLOAT3 = 3,
        SG_UNIFORMTYPE_FLOAT4 = 4,
        SG_UNIFORMTYPE_INT = 5,
        SG_UNIFORMTYPE_INT2 = 6,
        SG_UNIFORMTYPE_INT3 = 7,
        SG_UNIFORMTYPE_INT4 = 8,
        SG_UNIFORMTYPE_MAT4 = 9,
        SG_UNIFORMTYPE_NUM = 10,
        SG_UNIFORMTYPE_FORCE_U32 = 2147483647
    }

    public enum SgUniformLayout
    {
        SG_UNIFORMLAYOUT_DEFAULT = 0,
        SG_UNIFORMLAYOUT_NATIVE = 1,
        SG_UNIFORMLAYOUT_STD140 = 2,
        SG_UNIFORMLAYOUT_NUM = 3,
        SG_UNIFORMLAYOUT_FORCE_U32 = 2147483647
    }

    public enum SgCullMode
    {
        SG_CULLMODE_DEFAULT = 0,
        SG_CULLMODE_NONE = 1,
        SG_CULLMODE_FRONT = 2,
        SG_CULLMODE_BACK = 3,
        SG_CULLMODE_NUM = 4,
        SG_CULLMODE_FORCE_U32 = 2147483647
    }

    public enum SgFaceWinding
    {
        SG_FACEWINDING_DEFAULT = 0,
        SG_FACEWINDING_CCW = 1,
        SG_FACEWINDING_CW = 2,
        SG_FACEWINDING_NUM = 3,
        SG_FACEWINDING_FORCE_U32 = 2147483647
    }

    public enum SgCompareFunc
    {
        SG_COMPAREFUNC_DEFAULT = 0,
        SG_COMPAREFUNC_NEVER = 1,
        SG_COMPAREFUNC_LESS = 2,
        SG_COMPAREFUNC_EQUAL = 3,
        SG_COMPAREFUNC_LESS_EQUAL = 4,
        SG_COMPAREFUNC_GREATER = 5,
        SG_COMPAREFUNC_NOT_EQUAL = 6,
        SG_COMPAREFUNC_GREATER_EQUAL = 7,
        SG_COMPAREFUNC_ALWAYS = 8,
        SG_COMPAREFUNC_NUM = 9,
        SG_COMPAREFUNC_FORCE_U32 = 2147483647
    }

    public enum SgStencilOp
    {
        SG_STENCILOP_DEFAULT = 0,
        SG_STENCILOP_KEEP = 1,
        SG_STENCILOP_ZERO = 2,
        SG_STENCILOP_REPLACE = 3,
        SG_STENCILOP_INCR_CLAMP = 4,
        SG_STENCILOP_DECR_CLAMP = 5,
        SG_STENCILOP_INVERT = 6,
        SG_STENCILOP_INCR_WRAP = 7,
        SG_STENCILOP_DECR_WRAP = 8,
        SG_STENCILOP_NUM = 9,
        SG_STENCILOP_FORCE_U32 = 2147483647
    }

    public enum SgBlendFactor
    {
        SG_BLENDFACTOR_DEFAULT = 0,
        SG_BLENDFACTOR_ZERO = 1,
        SG_BLENDFACTOR_ONE = 2,
        SG_BLENDFACTOR_SRC_COLOR = 3,
        SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4,
        SG_BLENDFACTOR_SRC_ALPHA = 5,
        SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6,
        SG_BLENDFACTOR_DST_COLOR = 7,
        SG_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8,
        SG_BLENDFACTOR_DST_ALPHA = 9,
        SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10,
        SG_BLENDFACTOR_SRC_ALPHA_SATURATED = 11,
        SG_BLENDFACTOR_BLEND_COLOR = 12,
        SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR = 13,
        SG_BLENDFACTOR_BLEND_ALPHA = 14,
        SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA = 15,
        SG_BLENDFACTOR_NUM = 16,
        SG_BLENDFACTOR_FORCE_U32 = 2147483647
    }

    public enum SgBlendOp
    {
        SG_BLENDOP_DEFAULT = 0,
        SG_BLENDOP_ADD = 1,
        SG_BLENDOP_SUBTRACT = 2,
        SG_BLENDOP_REVERSE_SUBTRACT = 3,
        SG_BLENDOP_NUM = 4,
        SG_BLENDOP_FORCE_U32 = 2147483647
    }

    public enum SgColorMask
    {
        SG_COLORMASK_DEFAULT = 0,
        SG_COLORMASK_NONE = 16,
        SG_COLORMASK_R = 1,
        SG_COLORMASK_G = 2,
        SG_COLORMASK_RG = 3,
        SG_COLORMASK_B = 4,
        SG_COLORMASK_RB = 5,
        SG_COLORMASK_GB = 6,
        SG_COLORMASK_RGB = 7,
        SG_COLORMASK_A = 8,
        SG_COLORMASK_RA = 9,
        SG_COLORMASK_GA = 10,
        SG_COLORMASK_RGA = 11,
        SG_COLORMASK_BA = 12,
        SG_COLORMASK_RBA = 13,
        SG_COLORMASK_GBA = 14,
        SG_COLORMASK_RGBA = 15,
        SG_COLORMASK_FORCE_U32 = 2147483647
    }

    public enum SgAction
    {
        SG_ACTION_DEFAULT = 0,
        SG_ACTION_CLEAR = 1,
        SG_ACTION_LOAD = 2,
        SG_ACTION_DONTCARE = 3,
        SG_ACTION_NUM = 4,
        SG_ACTION_FORCE_U32 = 2147483647
    }

    public unsafe partial class SgBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint id;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_buffer@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBuffer>();

        protected bool __ownsNativeInstance;

        internal static SgBuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgBuffer(native.ToPointer(), skipVTables);
        }

        internal static SgBuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgBuffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgBuffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgBuffer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgBuffer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgBuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgBuffer(global::Sokol.SgBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgBuffer.__Internal*) __Instance) = *((global::Sokol.SgBuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }
    }

    public unsafe partial class SgImage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint id;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_image@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgImage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgImage>();

        protected bool __ownsNativeInstance;

        internal static SgImage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgImage(native.ToPointer(), skipVTables);
        }

        internal static SgImage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgImage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgImage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgImage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgImage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgImage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgImage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgImage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgImage(global::Sokol.SgImage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgImage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgImage.__Internal*) __Instance) = *((global::Sokol.SgImage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }
    }

    public unsafe partial class SgShader : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint id;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_shader@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShader>();

        protected bool __ownsNativeInstance;

        internal static SgShader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgShader(native.ToPointer(), skipVTables);
        }

        internal static SgShader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgShader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgShader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgShader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgShader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgShader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgShader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgShader(global::Sokol.SgShader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgShader.__Internal*) __Instance) = *((global::Sokol.SgShader.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }
    }

    public unsafe partial class SgPipeline : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint id;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_pipeline@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPipeline> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPipeline>();

        protected bool __ownsNativeInstance;

        internal static SgPipeline __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgPipeline(native.ToPointer(), skipVTables);
        }

        internal static SgPipeline __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgPipeline)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgPipeline __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgPipeline(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgPipeline(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgPipeline(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgPipeline()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgPipeline(global::Sokol.SgPipeline _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgPipeline.__Internal*) __Instance) = *((global::Sokol.SgPipeline.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }
    }

    public unsafe partial class SgPass : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint id;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_pass@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPass>();

        protected bool __ownsNativeInstance;

        internal static SgPass __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgPass(native.ToPointer(), skipVTables);
        }

        internal static SgPass __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgPass)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgPass __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgPass(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgPass(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgPass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgPass()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgPass(global::Sokol.SgPass _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgPass.__Internal*) __Instance) = *((global::Sokol.SgPass.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }
    }

    public unsafe partial class SgContext : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint id;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_context@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgContext>();

        protected bool __ownsNativeInstance;

        internal static SgContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgContext(native.ToPointer(), skipVTables);
        }

        internal static SgContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgContext()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgContext.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgContext(global::Sokol.SgContext _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgContext.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgContext.__Internal*) __Instance) = *((global::Sokol.SgContext.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }
    }

    public unsafe partial class SgRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr ptr;
            internal ulong size;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_range@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgRange>();

        protected bool __ownsNativeInstance;

        internal static SgRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgRange(native.ToPointer(), skipVTables);
        }

        internal static SgRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgRange(global::Sokol.SgRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgRange.__Internal*) __Instance) = *((global::Sokol.SgRange.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Ptr
        {
            get
            {
                return ((__Internal*)__Instance)->ptr;
            }
        }

        public ulong Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }
    }

    public unsafe partial class SgColor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float r;
            internal float g;
            internal float b;
            internal float a;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_color@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgColor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgColor>();

        protected bool __ownsNativeInstance;

        internal static SgColor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgColor(native.ToPointer(), skipVTables);
        }

        internal static SgColor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgColor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgColor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgColor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgColor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgColor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgColor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgColor(global::Sokol.SgColor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgColor.__Internal*) __Instance) = *((global::Sokol.SgColor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float R
        {
            get
            {
                return ((__Internal*)__Instance)->r;
            }

            set
            {
                ((__Internal*)__Instance)->r = value;
            }
        }

        public float G
        {
            get
            {
                return ((__Internal*)__Instance)->g;
            }

            set
            {
                ((__Internal*)__Instance)->g = value;
            }
        }

        public float B
        {
            get
            {
                return ((__Internal*)__Instance)->b;
            }

            set
            {
                ((__Internal*)__Instance)->b = value;
            }
        }

        public float A
        {
            get
            {
                return ((__Internal*)__Instance)->a;
            }

            set
            {
                ((__Internal*)__Instance)->a = value;
            }
        }
    }

    public unsafe partial class SgPixelformatInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal byte sample;
            internal byte filter;
            internal byte render;
            internal byte blend;
            internal byte msaa;
            internal byte depth;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_pixelformat_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPixelformatInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPixelformatInfo>();

        protected bool __ownsNativeInstance;

        internal static SgPixelformatInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgPixelformatInfo(native.ToPointer(), skipVTables);
        }

        internal static SgPixelformatInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgPixelformatInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgPixelformatInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgPixelformatInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgPixelformatInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgPixelformatInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgPixelformatInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPixelformatInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgPixelformatInfo(global::Sokol.SgPixelformatInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPixelformatInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgPixelformatInfo.__Internal*) __Instance) = *((global::Sokol.SgPixelformatInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Sample
        {
            get
            {
                return ((__Internal*)__Instance)->sample != 0;
            }

            set
            {
                ((__Internal*)__Instance)->sample = (byte) (value ? 1 : 0);
            }
        }

        public bool Filter
        {
            get
            {
                return ((__Internal*)__Instance)->filter != 0;
            }

            set
            {
                ((__Internal*)__Instance)->filter = (byte) (value ? 1 : 0);
            }
        }

        public bool Render
        {
            get
            {
                return ((__Internal*)__Instance)->render != 0;
            }

            set
            {
                ((__Internal*)__Instance)->render = (byte) (value ? 1 : 0);
            }
        }

        public bool Blend
        {
            get
            {
                return ((__Internal*)__Instance)->blend != 0;
            }

            set
            {
                ((__Internal*)__Instance)->blend = (byte) (value ? 1 : 0);
            }
        }

        public bool Msaa
        {
            get
            {
                return ((__Internal*)__Instance)->msaa != 0;
            }

            set
            {
                ((__Internal*)__Instance)->msaa = (byte) (value ? 1 : 0);
            }
        }

        public bool Depth
        {
            get
            {
                return ((__Internal*)__Instance)->depth != 0;
            }

            set
            {
                ((__Internal*)__Instance)->depth = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class SgFeatures : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 9)]
        public partial struct __Internal
        {
            internal byte instancing;
            internal byte origin_top_left;
            internal byte multiple_render_targets;
            internal byte msaa_render_targets;
            internal byte imagetype_3d;
            internal byte imagetype_array;
            internal byte image_clamp_to_border;
            internal byte mrt_independent_blend_state;
            internal byte mrt_independent_write_mask;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_features@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgFeatures> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgFeatures>();

        protected bool __ownsNativeInstance;

        internal static SgFeatures __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgFeatures(native.ToPointer(), skipVTables);
        }

        internal static SgFeatures __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgFeatures)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgFeatures __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgFeatures(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgFeatures(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgFeatures(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgFeatures()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgFeatures.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgFeatures(global::Sokol.SgFeatures _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgFeatures.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgFeatures.__Internal*) __Instance) = *((global::Sokol.SgFeatures.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Instancing
        {
            get
            {
                return ((__Internal*)__Instance)->instancing != 0;
            }

            set
            {
                ((__Internal*)__Instance)->instancing = (byte) (value ? 1 : 0);
            }
        }

        public bool OriginTopLeft
        {
            get
            {
                return ((__Internal*)__Instance)->origin_top_left != 0;
            }

            set
            {
                ((__Internal*)__Instance)->origin_top_left = (byte) (value ? 1 : 0);
            }
        }

        public bool MultipleRenderTargets
        {
            get
            {
                return ((__Internal*)__Instance)->multiple_render_targets != 0;
            }

            set
            {
                ((__Internal*)__Instance)->multiple_render_targets = (byte) (value ? 1 : 0);
            }
        }

        public bool MsaaRenderTargets
        {
            get
            {
                return ((__Internal*)__Instance)->msaa_render_targets != 0;
            }

            set
            {
                ((__Internal*)__Instance)->msaa_render_targets = (byte) (value ? 1 : 0);
            }
        }

        public bool Imagetype3d
        {
            get
            {
                return ((__Internal*)__Instance)->imagetype_3d != 0;
            }

            set
            {
                ((__Internal*)__Instance)->imagetype_3d = (byte) (value ? 1 : 0);
            }
        }

        public bool ImagetypeArray
        {
            get
            {
                return ((__Internal*)__Instance)->imagetype_array != 0;
            }

            set
            {
                ((__Internal*)__Instance)->imagetype_array = (byte) (value ? 1 : 0);
            }
        }

        public bool ImageClampToBorder
        {
            get
            {
                return ((__Internal*)__Instance)->image_clamp_to_border != 0;
            }

            set
            {
                ((__Internal*)__Instance)->image_clamp_to_border = (byte) (value ? 1 : 0);
            }
        }

        public bool MrtIndependentBlendState
        {
            get
            {
                return ((__Internal*)__Instance)->mrt_independent_blend_state != 0;
            }

            set
            {
                ((__Internal*)__Instance)->mrt_independent_blend_state = (byte) (value ? 1 : 0);
            }
        }

        public bool MrtIndependentWriteMask
        {
            get
            {
                return ((__Internal*)__Instance)->mrt_independent_write_mask != 0;
            }

            set
            {
                ((__Internal*)__Instance)->mrt_independent_write_mask = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class SgLimits : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal int max_image_size_2d;
            internal int max_image_size_cube;
            internal int max_image_size_3d;
            internal int max_image_size_array;
            internal int max_image_array_layers;
            internal int max_vertex_attrs;
            internal int gl_max_vertex_uniform_vectors;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_limits@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgLimits> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgLimits>();

        protected bool __ownsNativeInstance;

        internal static SgLimits __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgLimits(native.ToPointer(), skipVTables);
        }

        internal static SgLimits __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgLimits)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgLimits __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgLimits(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgLimits(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgLimits(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgLimits()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgLimits.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgLimits(global::Sokol.SgLimits _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgLimits.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgLimits.__Internal*) __Instance) = *((global::Sokol.SgLimits.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int MaxImageSize2d
        {
            get
            {
                return ((__Internal*)__Instance)->max_image_size_2d;
            }

            set
            {
                ((__Internal*)__Instance)->max_image_size_2d = value;
            }
        }

        public int MaxImageSizeCube
        {
            get
            {
                return ((__Internal*)__Instance)->max_image_size_cube;
            }

            set
            {
                ((__Internal*)__Instance)->max_image_size_cube = value;
            }
        }

        public int MaxImageSize3d
        {
            get
            {
                return ((__Internal*)__Instance)->max_image_size_3d;
            }

            set
            {
                ((__Internal*)__Instance)->max_image_size_3d = value;
            }
        }

        public int MaxImageSizeArray
        {
            get
            {
                return ((__Internal*)__Instance)->max_image_size_array;
            }

            set
            {
                ((__Internal*)__Instance)->max_image_size_array = value;
            }
        }

        public int MaxImageArrayLayers
        {
            get
            {
                return ((__Internal*)__Instance)->max_image_array_layers;
            }

            set
            {
                ((__Internal*)__Instance)->max_image_array_layers = value;
            }
        }

        public int MaxVertexAttrs
        {
            get
            {
                return ((__Internal*)__Instance)->max_vertex_attrs;
            }

            set
            {
                ((__Internal*)__Instance)->max_vertex_attrs = value;
            }
        }

        public int GlMaxVertexUniformVectors
        {
            get
            {
                return ((__Internal*)__Instance)->gl_max_vertex_uniform_vectors;
            }

            set
            {
                ((__Internal*)__Instance)->gl_max_vertex_uniform_vectors = value;
            }
        }
    }

    public unsafe partial class SgColorAttachmentAction : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal global::Sokol.SgAction action;
            internal global::Sokol.SgColor.__Internal value;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_color_attachment_action@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgColorAttachmentAction> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgColorAttachmentAction>();

        protected bool __ownsNativeInstance;

        internal static SgColorAttachmentAction __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgColorAttachmentAction(native.ToPointer(), skipVTables);
        }

        internal static SgColorAttachmentAction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgColorAttachmentAction)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgColorAttachmentAction __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgColorAttachmentAction(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgColorAttachmentAction(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgColorAttachmentAction(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgColorAttachmentAction()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgColorAttachmentAction.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgColorAttachmentAction(global::Sokol.SgColorAttachmentAction _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgColorAttachmentAction.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgColorAttachmentAction.__Internal*) __Instance) = *((global::Sokol.SgColorAttachmentAction.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgAction Action
        {
            get
            {
                return ((__Internal*)__Instance)->action;
            }

            set
            {
                ((__Internal*)__Instance)->action = value;
            }
        }

        public global::Sokol.SgColor Value
        {
            get
            {
                return global::Sokol.SgColor.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->value));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->value = *(global::Sokol.SgColor.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class SgDepthAttachmentAction : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::Sokol.SgAction action;
            internal float value;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_depth_attachment_action@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgDepthAttachmentAction> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgDepthAttachmentAction>();

        protected bool __ownsNativeInstance;

        internal static SgDepthAttachmentAction __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgDepthAttachmentAction(native.ToPointer(), skipVTables);
        }

        internal static SgDepthAttachmentAction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgDepthAttachmentAction)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgDepthAttachmentAction __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgDepthAttachmentAction(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgDepthAttachmentAction(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgDepthAttachmentAction(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgDepthAttachmentAction()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgDepthAttachmentAction.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgDepthAttachmentAction(global::Sokol.SgDepthAttachmentAction _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgDepthAttachmentAction.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgDepthAttachmentAction.__Internal*) __Instance) = *((global::Sokol.SgDepthAttachmentAction.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgAction Action
        {
            get
            {
                return ((__Internal*)__Instance)->action;
            }

            set
            {
                ((__Internal*)__Instance)->action = value;
            }
        }

        public float Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }
    }

    public unsafe partial class SgStencilAttachmentAction : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::Sokol.SgAction action;
            internal byte value;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_stencil_attachment_action@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgStencilAttachmentAction> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgStencilAttachmentAction>();

        protected bool __ownsNativeInstance;

        internal static SgStencilAttachmentAction __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgStencilAttachmentAction(native.ToPointer(), skipVTables);
        }

        internal static SgStencilAttachmentAction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgStencilAttachmentAction)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgStencilAttachmentAction __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgStencilAttachmentAction(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgStencilAttachmentAction(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgStencilAttachmentAction(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgStencilAttachmentAction()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgStencilAttachmentAction.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgStencilAttachmentAction(global::Sokol.SgStencilAttachmentAction _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgStencilAttachmentAction.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgStencilAttachmentAction.__Internal*) __Instance) = *((global::Sokol.SgStencilAttachmentAction.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgAction Action
        {
            get
            {
                return ((__Internal*)__Instance)->action;
            }

            set
            {
                ((__Internal*)__Instance)->action = value;
            }
        }

        public byte Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }
    }

    public unsafe partial class SgPassAction : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 104)]
        public partial struct __Internal
        {
            internal uint _start_canary;
            internal fixed byte colors[80];
            internal global::Sokol.SgDepthAttachmentAction.__Internal depth;
            internal global::Sokol.SgStencilAttachmentAction.__Internal stencil;
            internal uint _end_canary;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_pass_action@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPassAction> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPassAction>();

        protected bool __ownsNativeInstance;

        internal static SgPassAction __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgPassAction(native.ToPointer(), skipVTables);
        }

        internal static SgPassAction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgPassAction)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgPassAction __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgPassAction(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgPassAction(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgPassAction(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgPassAction()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPassAction.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgPassAction(global::Sokol.SgPassAction _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPassAction.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgPassAction.__Internal*) __Instance) = *((global::Sokol.SgPassAction.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint StartCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_start_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_start_canary = value;
            }
        }

        public global::Sokol.SgColorAttachmentAction[] Colors
        {
            get
            {
                global::Sokol.SgColorAttachmentAction[] __value = null;
                if (((__Internal*)__Instance)->colors != null)
                {
                    __value = new global::Sokol.SgColorAttachmentAction[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = global::Sokol.SgColorAttachmentAction.__GetOrCreateInstance((IntPtr)((global::Sokol.SgColorAttachmentAction.__Internal*)&(((__Internal*)__Instance)->colors[i * sizeof(global::Sokol.SgColorAttachmentAction.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 4)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 4; i++)
                        *(global::Sokol.SgColorAttachmentAction.__Internal*) &((__Internal*)__Instance)->colors[i * sizeof(global::Sokol.SgColorAttachmentAction.__Internal)] = *(global::Sokol.SgColorAttachmentAction.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::Sokol.SgDepthAttachmentAction Depth
        {
            get
            {
                return global::Sokol.SgDepthAttachmentAction.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->depth));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->depth = *(global::Sokol.SgDepthAttachmentAction.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SgStencilAttachmentAction Stencil
        {
            get
            {
                return global::Sokol.SgStencilAttachmentAction.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->stencil));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->stencil = *(global::Sokol.SgStencilAttachmentAction.__Internal*) value.__Instance;
            }
        }

        public uint EndCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_end_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_end_canary = value;
            }
        }
    }

    public unsafe partial class SgBindings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 176)]
        public partial struct __Internal
        {
            internal uint _start_canary;
            internal fixed byte vertex_buffers[32];
            internal fixed int vertex_buffer_offsets[8];
            internal global::Sokol.SgBuffer.__Internal index_buffer;
            internal int index_buffer_offset;
            internal fixed byte vs_images[48];
            internal fixed byte fs_images[48];
            internal uint _end_canary;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_bindings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBindings> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBindings>();

        protected bool __ownsNativeInstance;

        internal static SgBindings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgBindings(native.ToPointer(), skipVTables);
        }

        internal static SgBindings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgBindings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgBindings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgBindings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgBindings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgBindings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgBindings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBindings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgBindings(global::Sokol.SgBindings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBindings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgBindings.__Internal*) __Instance) = *((global::Sokol.SgBindings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint StartCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_start_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_start_canary = value;
            }
        }

        public global::Sokol.SgBuffer[] VertexBuffers
        {
            get
            {
                global::Sokol.SgBuffer[] __value = null;
                if (((__Internal*)__Instance)->vertex_buffers != null)
                {
                    __value = new global::Sokol.SgBuffer[8];
                    for (int i = 0; i < 8; i++)
                        __value[i] = global::Sokol.SgBuffer.__GetOrCreateInstance((IntPtr)((global::Sokol.SgBuffer.__Internal*)&(((__Internal*)__Instance)->vertex_buffers[i * sizeof(global::Sokol.SgBuffer.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 8)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 8; i++)
                        *(global::Sokol.SgBuffer.__Internal*) &((__Internal*)__Instance)->vertex_buffers[i * sizeof(global::Sokol.SgBuffer.__Internal)] = *(global::Sokol.SgBuffer.__Internal*)value[i].__Instance;
                }
            }
        }

        public int[] VertexBufferOffsets
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->vertex_buffer_offsets, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->vertex_buffer_offsets[i] = value[i];
                }
            }
        }

        public global::Sokol.SgBuffer IndexBuffer
        {
            get
            {
                return global::Sokol.SgBuffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->index_buffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->index_buffer = *(global::Sokol.SgBuffer.__Internal*) value.__Instance;
            }
        }

        public int IndexBufferOffset
        {
            get
            {
                return ((__Internal*)__Instance)->index_buffer_offset;
            }

            set
            {
                ((__Internal*)__Instance)->index_buffer_offset = value;
            }
        }

        public global::Sokol.SgImage[] VsImages
        {
            get
            {
                global::Sokol.SgImage[] __value = null;
                if (((__Internal*)__Instance)->vs_images != null)
                {
                    __value = new global::Sokol.SgImage[12];
                    for (int i = 0; i < 12; i++)
                        __value[i] = global::Sokol.SgImage.__GetOrCreateInstance((IntPtr)((global::Sokol.SgImage.__Internal*)&(((__Internal*)__Instance)->vs_images[i * sizeof(global::Sokol.SgImage.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 12)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 12; i++)
                        *(global::Sokol.SgImage.__Internal*) &((__Internal*)__Instance)->vs_images[i * sizeof(global::Sokol.SgImage.__Internal)] = *(global::Sokol.SgImage.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::Sokol.SgImage[] FsImages
        {
            get
            {
                global::Sokol.SgImage[] __value = null;
                if (((__Internal*)__Instance)->fs_images != null)
                {
                    __value = new global::Sokol.SgImage[12];
                    for (int i = 0; i < 12; i++)
                        __value[i] = global::Sokol.SgImage.__GetOrCreateInstance((IntPtr)((global::Sokol.SgImage.__Internal*)&(((__Internal*)__Instance)->fs_images[i * sizeof(global::Sokol.SgImage.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 12)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 12; i++)
                        *(global::Sokol.SgImage.__Internal*) &((__Internal*)__Instance)->fs_images[i * sizeof(global::Sokol.SgImage.__Internal)] = *(global::Sokol.SgImage.__Internal*)value[i].__Instance;
                }
            }
        }

        public uint EndCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_end_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_end_canary = value;
            }
        }
    }

    public unsafe partial class SgBufferDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96)]
        public partial struct __Internal
        {
            internal uint _start_canary;
            internal ulong size;
            internal global::Sokol.SgBufferType type;
            internal global::Sokol.SgUsage usage;
            internal global::Sokol.SgRange.__Internal data;
            internal __IntPtr label;
            internal fixed uint gl_buffers[2];
            internal void* mtl_buffers;
            internal __IntPtr d3d11_buffer;
            internal __IntPtr wgpu_buffer;
            internal uint _end_canary;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_buffer_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBufferDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBufferDesc>();

        private bool __label_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SgBufferDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgBufferDesc(native.ToPointer(), skipVTables);
        }

        internal static SgBufferDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgBufferDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgBufferDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgBufferDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgBufferDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgBufferDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgBufferDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBufferDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgBufferDesc(global::Sokol.SgBufferDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBufferDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgBufferDesc.__Internal*) __Instance) = *((global::Sokol.SgBufferDesc.__Internal*) _0.__Instance);
            if (_0.__label_OwnsNativeMemory)
                this.Label = _0.Label;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__label_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->label);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint StartCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_start_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_start_canary = value;
            }
        }

        public ulong Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        public global::Sokol.SgBufferType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public global::Sokol.SgUsage Usage
        {
            get
            {
                return ((__Internal*)__Instance)->usage;
            }

            set
            {
                ((__Internal*)__Instance)->usage = value;
            }
        }

        public global::Sokol.SgRange Data
        {
            get
            {
                return global::Sokol.SgRange.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->data));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->data = *(global::Sokol.SgRange.__Internal*) value.__Instance;
            }
        }

        public string Label
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->label);
            }

            set
            {
                if (__label_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->label);
                __label_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->label = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->label = (__IntPtr) __bytePtr0;
            }
        }

        public uint[] GlBuffers
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->gl_buffers, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->gl_buffers[i] = value[i];
                }
            }
        }

        private __IntPtr[] __mtl_buffers;

        private bool __mtl_buffersInitialised;
        public __IntPtr[] MtlBuffers
        {
            get
            {
                if (!__mtl_buffersInitialised)
                {
                    __mtl_buffers = null;
                    __mtl_buffersInitialised = true;
                }
                return __mtl_buffers;
            }

            set
            {
                __mtl_buffers = value;
                if (!__mtl_buffersInitialised)
                {
                    __mtl_buffersInitialised = true;
                }
            }
        }

        public __IntPtr D3d11Buffer
        {
            get
            {
                return ((__Internal*)__Instance)->d3d11_buffer;
            }
        }

        public __IntPtr WgpuBuffer
        {
            get
            {
                return ((__Internal*)__Instance)->wgpu_buffer;
            }
        }

        public uint EndCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_end_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_end_canary = value;
            }
        }
    }

    public unsafe partial class SgImageData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1536)]
        public partial struct __Internal
        {
            internal fixed byte subimage[96];

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_image_data@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgImageData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgImageData>();

        protected bool __ownsNativeInstance;

        internal static SgImageData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgImageData(native.ToPointer(), skipVTables);
        }

        internal static SgImageData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgImageData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgImageData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgImageData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgImageData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgImageData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgImageData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgImageData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgImageData(global::Sokol.SgImageData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgImageData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgImageData.__Internal*) __Instance) = *((global::Sokol.SgImageData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    public unsafe partial class SgImageDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1688)]
        public partial struct __Internal
        {
            internal uint _start_canary;
            internal global::Sokol.SgImageType type;
            internal byte render_target;
            internal int width;
            internal int height;
            internal int num_slices;
            internal int num_mipmaps;
            internal global::Sokol.SgUsage usage;
            internal global::Sokol.SgPixelFormat pixel_format;
            internal int sample_count;
            internal global::Sokol.SgFilter min_filter;
            internal global::Sokol.SgFilter mag_filter;
            internal global::Sokol.SgWrap wrap_u;
            internal global::Sokol.SgWrap wrap_v;
            internal global::Sokol.SgWrap wrap_w;
            internal global::Sokol.SgBorderColor border_color;
            internal uint max_anisotropy;
            internal float min_lod;
            internal float max_lod;
            internal global::Sokol.SgImageData.__Internal data;
            internal __IntPtr label;
            internal fixed uint gl_textures[2];
            internal uint gl_texture_target;
            internal void* mtl_textures;
            internal __IntPtr d3d11_texture;
            internal __IntPtr d3d11_shader_resource_view;
            internal __IntPtr wgpu_texture;
            internal uint _end_canary;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_image_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgImageDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgImageDesc>();

        private bool __label_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SgImageDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgImageDesc(native.ToPointer(), skipVTables);
        }

        internal static SgImageDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgImageDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgImageDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgImageDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgImageDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgImageDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgImageDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgImageDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgImageDesc(global::Sokol.SgImageDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgImageDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgImageDesc.__Internal*) __Instance) = *((global::Sokol.SgImageDesc.__Internal*) _0.__Instance);
            if (_0.__label_OwnsNativeMemory)
                this.Label = _0.Label;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__label_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->label);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint StartCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_start_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_start_canary = value;
            }
        }

        public global::Sokol.SgImageType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public bool RenderTarget
        {
            get
            {
                return ((__Internal*)__Instance)->render_target != 0;
            }

            set
            {
                ((__Internal*)__Instance)->render_target = (byte) (value ? 1 : 0);
            }
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public int NumSlices
        {
            get
            {
                return ((__Internal*)__Instance)->num_slices;
            }

            set
            {
                ((__Internal*)__Instance)->num_slices = value;
            }
        }

        public int NumMipmaps
        {
            get
            {
                return ((__Internal*)__Instance)->num_mipmaps;
            }

            set
            {
                ((__Internal*)__Instance)->num_mipmaps = value;
            }
        }

        public global::Sokol.SgUsage Usage
        {
            get
            {
                return ((__Internal*)__Instance)->usage;
            }

            set
            {
                ((__Internal*)__Instance)->usage = value;
            }
        }

        public global::Sokol.SgPixelFormat PixelFormat
        {
            get
            {
                return ((__Internal*)__Instance)->pixel_format;
            }

            set
            {
                ((__Internal*)__Instance)->pixel_format = value;
            }
        }

        public int SampleCount
        {
            get
            {
                return ((__Internal*)__Instance)->sample_count;
            }

            set
            {
                ((__Internal*)__Instance)->sample_count = value;
            }
        }

        public global::Sokol.SgFilter MinFilter
        {
            get
            {
                return ((__Internal*)__Instance)->min_filter;
            }

            set
            {
                ((__Internal*)__Instance)->min_filter = value;
            }
        }

        public global::Sokol.SgFilter MagFilter
        {
            get
            {
                return ((__Internal*)__Instance)->mag_filter;
            }

            set
            {
                ((__Internal*)__Instance)->mag_filter = value;
            }
        }

        public global::Sokol.SgWrap WrapU
        {
            get
            {
                return ((__Internal*)__Instance)->wrap_u;
            }

            set
            {
                ((__Internal*)__Instance)->wrap_u = value;
            }
        }

        public global::Sokol.SgWrap WrapV
        {
            get
            {
                return ((__Internal*)__Instance)->wrap_v;
            }

            set
            {
                ((__Internal*)__Instance)->wrap_v = value;
            }
        }

        public global::Sokol.SgWrap WrapW
        {
            get
            {
                return ((__Internal*)__Instance)->wrap_w;
            }

            set
            {
                ((__Internal*)__Instance)->wrap_w = value;
            }
        }

        public global::Sokol.SgBorderColor BorderColor
        {
            get
            {
                return ((__Internal*)__Instance)->border_color;
            }

            set
            {
                ((__Internal*)__Instance)->border_color = value;
            }
        }

        public uint MaxAnisotropy
        {
            get
            {
                return ((__Internal*)__Instance)->max_anisotropy;
            }

            set
            {
                ((__Internal*)__Instance)->max_anisotropy = value;
            }
        }

        public float MinLod
        {
            get
            {
                return ((__Internal*)__Instance)->min_lod;
            }

            set
            {
                ((__Internal*)__Instance)->min_lod = value;
            }
        }

        public float MaxLod
        {
            get
            {
                return ((__Internal*)__Instance)->max_lod;
            }

            set
            {
                ((__Internal*)__Instance)->max_lod = value;
            }
        }

        public global::Sokol.SgImageData Data
        {
            get
            {
                return global::Sokol.SgImageData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->data));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->data = *(global::Sokol.SgImageData.__Internal*) value.__Instance;
            }
        }

        public string Label
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->label);
            }

            set
            {
                if (__label_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->label);
                __label_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->label = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->label = (__IntPtr) __bytePtr0;
            }
        }

        public uint[] GlTextures
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->gl_textures, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->gl_textures[i] = value[i];
                }
            }
        }

        public uint GlTextureTarget
        {
            get
            {
                return ((__Internal*)__Instance)->gl_texture_target;
            }

            set
            {
                ((__Internal*)__Instance)->gl_texture_target = value;
            }
        }

        private __IntPtr[] __mtl_textures;

        private bool __mtl_texturesInitialised;
        public __IntPtr[] MtlTextures
        {
            get
            {
                if (!__mtl_texturesInitialised)
                {
                    __mtl_textures = null;
                    __mtl_texturesInitialised = true;
                }
                return __mtl_textures;
            }

            set
            {
                __mtl_textures = value;
                if (!__mtl_texturesInitialised)
                {
                    __mtl_texturesInitialised = true;
                }
            }
        }

        public __IntPtr D3d11Texture
        {
            get
            {
                return ((__Internal*)__Instance)->d3d11_texture;
            }
        }

        public __IntPtr D3d11ShaderResourceView
        {
            get
            {
                return ((__Internal*)__Instance)->d3d11_shader_resource_view;
            }
        }

        public __IntPtr WgpuTexture
        {
            get
            {
                return ((__Internal*)__Instance)->wgpu_texture;
            }
        }

        public uint EndCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_end_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_end_canary = value;
            }
        }
    }

    public unsafe partial class SgShaderAttrDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr name;
            internal __IntPtr sem_name;
            internal int sem_index;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_shader_attr_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderAttrDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderAttrDesc>();

        private bool __name_OwnsNativeMemory = false;
        private bool __sem_name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SgShaderAttrDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgShaderAttrDesc(native.ToPointer(), skipVTables);
        }

        internal static SgShaderAttrDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgShaderAttrDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgShaderAttrDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgShaderAttrDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgShaderAttrDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgShaderAttrDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgShaderAttrDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderAttrDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgShaderAttrDesc(global::Sokol.SgShaderAttrDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderAttrDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgShaderAttrDesc.__Internal*) __Instance) = *((global::Sokol.SgShaderAttrDesc.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
            if (_0.__sem_name_OwnsNativeMemory)
                this.SemName = _0.SemName;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__sem_name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->sem_name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }

        public string SemName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->sem_name);
            }

            set
            {
                if (__sem_name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->sem_name);
                __sem_name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->sem_name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->sem_name = (__IntPtr) __bytePtr0;
            }
        }

        public int SemIndex
        {
            get
            {
                return ((__Internal*)__Instance)->sem_index;
            }

            set
            {
                ((__Internal*)__Instance)->sem_index = value;
            }
        }
    }

    public unsafe partial class SgShaderUniformDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr name;
            internal global::Sokol.SgUniformType type;
            internal int array_count;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_shader_uniform_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderUniformDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderUniformDesc>();

        private bool __name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SgShaderUniformDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgShaderUniformDesc(native.ToPointer(), skipVTables);
        }

        internal static SgShaderUniformDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgShaderUniformDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgShaderUniformDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgShaderUniformDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgShaderUniformDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgShaderUniformDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgShaderUniformDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderUniformDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgShaderUniformDesc(global::Sokol.SgShaderUniformDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderUniformDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgShaderUniformDesc.__Internal*) __Instance) = *((global::Sokol.SgShaderUniformDesc.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }

        public global::Sokol.SgUniformType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public int ArrayCount
        {
            get
            {
                return ((__Internal*)__Instance)->array_count;
            }

            set
            {
                ((__Internal*)__Instance)->array_count = value;
            }
        }
    }

    public unsafe partial class SgShaderUniformBlockDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 272)]
        public partial struct __Internal
        {
            internal ulong size;
            internal global::Sokol.SgUniformLayout layout;
            internal fixed byte uniformsPadding[4];
            internal fixed byte uniforms[256];

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_shader_uniform_block_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderUniformBlockDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderUniformBlockDesc>();

        protected bool __ownsNativeInstance;

        internal static SgShaderUniformBlockDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgShaderUniformBlockDesc(native.ToPointer(), skipVTables);
        }

        internal static SgShaderUniformBlockDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgShaderUniformBlockDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgShaderUniformBlockDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgShaderUniformBlockDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgShaderUniformBlockDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgShaderUniformBlockDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgShaderUniformBlockDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderUniformBlockDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgShaderUniformBlockDesc(global::Sokol.SgShaderUniformBlockDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderUniformBlockDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgShaderUniformBlockDesc.__Internal*) __Instance) = *((global::Sokol.SgShaderUniformBlockDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        public global::Sokol.SgUniformLayout Layout
        {
            get
            {
                return ((__Internal*)__Instance)->layout;
            }

            set
            {
                ((__Internal*)__Instance)->layout = value;
            }
        }

        public global::Sokol.SgShaderUniformDesc[] Uniforms
        {
            get
            {
                global::Sokol.SgShaderUniformDesc[] __value = null;
                if (((__Internal*)__Instance)->uniforms != null)
                {
                    __value = new global::Sokol.SgShaderUniformDesc[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = global::Sokol.SgShaderUniformDesc.__GetOrCreateInstance((IntPtr)((global::Sokol.SgShaderUniformDesc.__Internal*)&(((__Internal*)__Instance)->uniforms[i * sizeof(global::Sokol.SgShaderUniformDesc.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 16)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 16; i++)
                        *(global::Sokol.SgShaderUniformDesc.__Internal*) &((__Internal*)__Instance)->uniforms[i * sizeof(global::Sokol.SgShaderUniformDesc.__Internal)] = *(global::Sokol.SgShaderUniformDesc.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class SgShaderImageDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr name;
            internal global::Sokol.SgImageType image_type;
            internal global::Sokol.SgSamplerType sampler_type;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_shader_image_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderImageDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderImageDesc>();

        private bool __name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SgShaderImageDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgShaderImageDesc(native.ToPointer(), skipVTables);
        }

        internal static SgShaderImageDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgShaderImageDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgShaderImageDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgShaderImageDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgShaderImageDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgShaderImageDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgShaderImageDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderImageDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgShaderImageDesc(global::Sokol.SgShaderImageDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderImageDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgShaderImageDesc.__Internal*) __Instance) = *((global::Sokol.SgShaderImageDesc.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }

        public global::Sokol.SgImageType ImageType
        {
            get
            {
                return ((__Internal*)__Instance)->image_type;
            }

            set
            {
                ((__Internal*)__Instance)->image_type = value;
            }
        }

        public global::Sokol.SgSamplerType SamplerType
        {
            get
            {
                return ((__Internal*)__Instance)->sampler_type;
            }

            set
            {
                ((__Internal*)__Instance)->sampler_type = value;
            }
        }
    }

    public unsafe partial class SgShaderStageDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1320)]
        public partial struct __Internal
        {
            internal __IntPtr source;
            internal global::Sokol.SgRange.__Internal bytecode;
            internal __IntPtr entry;
            internal __IntPtr d3d11_target;
            internal fixed byte uniform_blocks[1088];
            internal fixed byte images[192];

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_shader_stage_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderStageDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderStageDesc>();

        private bool __source_OwnsNativeMemory = false;
        private bool __entry_OwnsNativeMemory = false;
        private bool __d3d11_target_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SgShaderStageDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgShaderStageDesc(native.ToPointer(), skipVTables);
        }

        internal static SgShaderStageDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgShaderStageDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgShaderStageDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgShaderStageDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgShaderStageDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgShaderStageDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgShaderStageDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderStageDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgShaderStageDesc(global::Sokol.SgShaderStageDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderStageDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgShaderStageDesc.__Internal*) __Instance) = *((global::Sokol.SgShaderStageDesc.__Internal*) _0.__Instance);
            if (_0.__source_OwnsNativeMemory)
                this.Source = _0.Source;
            if (_0.__entry_OwnsNativeMemory)
                this.Entry = _0.Entry;
            if (_0.__d3d11_target_OwnsNativeMemory)
                this.D3d11Target = _0.D3d11Target;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__source_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->source);
            if (__entry_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->entry);
            if (__d3d11_target_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->d3d11_target);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Source
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->source);
            }

            set
            {
                if (__source_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->source);
                __source_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->source = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->source = (__IntPtr) __bytePtr0;
            }
        }

        public global::Sokol.SgRange Bytecode
        {
            get
            {
                return global::Sokol.SgRange.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->bytecode));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->bytecode = *(global::Sokol.SgRange.__Internal*) value.__Instance;
            }
        }

        public string Entry
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->entry);
            }

            set
            {
                if (__entry_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->entry);
                __entry_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->entry = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->entry = (__IntPtr) __bytePtr0;
            }
        }

        public string D3d11Target
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->d3d11_target);
            }

            set
            {
                if (__d3d11_target_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->d3d11_target);
                __d3d11_target_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->d3d11_target = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->d3d11_target = (__IntPtr) __bytePtr0;
            }
        }

        public global::Sokol.SgShaderUniformBlockDesc[] UniformBlocks
        {
            get
            {
                global::Sokol.SgShaderUniformBlockDesc[] __value = null;
                if (((__Internal*)__Instance)->uniform_blocks != null)
                {
                    __value = new global::Sokol.SgShaderUniformBlockDesc[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = global::Sokol.SgShaderUniformBlockDesc.__GetOrCreateInstance((IntPtr)((global::Sokol.SgShaderUniformBlockDesc.__Internal*)&(((__Internal*)__Instance)->uniform_blocks[i * sizeof(global::Sokol.SgShaderUniformBlockDesc.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 4)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 4; i++)
                        *(global::Sokol.SgShaderUniformBlockDesc.__Internal*) &((__Internal*)__Instance)->uniform_blocks[i * sizeof(global::Sokol.SgShaderUniformBlockDesc.__Internal)] = *(global::Sokol.SgShaderUniformBlockDesc.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::Sokol.SgShaderImageDesc[] Images
        {
            get
            {
                global::Sokol.SgShaderImageDesc[] __value = null;
                if (((__Internal*)__Instance)->images != null)
                {
                    __value = new global::Sokol.SgShaderImageDesc[12];
                    for (int i = 0; i < 12; i++)
                        __value[i] = global::Sokol.SgShaderImageDesc.__GetOrCreateInstance((IntPtr)((global::Sokol.SgShaderImageDesc.__Internal*)&(((__Internal*)__Instance)->images[i * sizeof(global::Sokol.SgShaderImageDesc.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 12)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 12; i++)
                        *(global::Sokol.SgShaderImageDesc.__Internal*) &((__Internal*)__Instance)->images[i * sizeof(global::Sokol.SgShaderImageDesc.__Internal)] = *(global::Sokol.SgShaderImageDesc.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class SgShaderDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3048)]
        public partial struct __Internal
        {
            internal uint _start_canary;
            internal fixed byte attrsPadding[4];
            internal fixed byte attrs[384];
            internal global::Sokol.SgShaderStageDesc.__Internal vs;
            internal global::Sokol.SgShaderStageDesc.__Internal fs;
            internal __IntPtr label;
            internal uint _end_canary;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_shader_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderDesc>();

        private bool __label_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SgShaderDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgShaderDesc(native.ToPointer(), skipVTables);
        }

        internal static SgShaderDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgShaderDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgShaderDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgShaderDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgShaderDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgShaderDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgShaderDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgShaderDesc(global::Sokol.SgShaderDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgShaderDesc.__Internal*) __Instance) = *((global::Sokol.SgShaderDesc.__Internal*) _0.__Instance);
            if (_0.__label_OwnsNativeMemory)
                this.Label = _0.Label;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__label_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->label);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint StartCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_start_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_start_canary = value;
            }
        }

        public global::Sokol.SgShaderAttrDesc[] Attrs
        {
            get
            {
                global::Sokol.SgShaderAttrDesc[] __value = null;
                if (((__Internal*)__Instance)->attrs != null)
                {
                    __value = new global::Sokol.SgShaderAttrDesc[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = global::Sokol.SgShaderAttrDesc.__GetOrCreateInstance((IntPtr)((global::Sokol.SgShaderAttrDesc.__Internal*)&(((__Internal*)__Instance)->attrs[i * sizeof(global::Sokol.SgShaderAttrDesc.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 16)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 16; i++)
                        *(global::Sokol.SgShaderAttrDesc.__Internal*) &((__Internal*)__Instance)->attrs[i * sizeof(global::Sokol.SgShaderAttrDesc.__Internal)] = *(global::Sokol.SgShaderAttrDesc.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::Sokol.SgShaderStageDesc Vs
        {
            get
            {
                return global::Sokol.SgShaderStageDesc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->vs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->vs = *(global::Sokol.SgShaderStageDesc.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SgShaderStageDesc Fs
        {
            get
            {
                return global::Sokol.SgShaderStageDesc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->fs = *(global::Sokol.SgShaderStageDesc.__Internal*) value.__Instance;
            }
        }

        public string Label
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->label);
            }

            set
            {
                if (__label_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->label);
                __label_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->label = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->label = (__IntPtr) __bytePtr0;
            }
        }

        public uint EndCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_end_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_end_canary = value;
            }
        }
    }

    public unsafe partial class SgBufferLayoutDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal int stride;
            internal global::Sokol.SgVertexStep step_func;
            internal int step_rate;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_buffer_layout_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBufferLayoutDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBufferLayoutDesc>();

        protected bool __ownsNativeInstance;

        internal static SgBufferLayoutDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgBufferLayoutDesc(native.ToPointer(), skipVTables);
        }

        internal static SgBufferLayoutDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgBufferLayoutDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgBufferLayoutDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgBufferLayoutDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgBufferLayoutDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgBufferLayoutDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgBufferLayoutDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBufferLayoutDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgBufferLayoutDesc(global::Sokol.SgBufferLayoutDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBufferLayoutDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgBufferLayoutDesc.__Internal*) __Instance) = *((global::Sokol.SgBufferLayoutDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Stride
        {
            get
            {
                return ((__Internal*)__Instance)->stride;
            }

            set
            {
                ((__Internal*)__Instance)->stride = value;
            }
        }

        public global::Sokol.SgVertexStep StepFunc
        {
            get
            {
                return ((__Internal*)__Instance)->step_func;
            }

            set
            {
                ((__Internal*)__Instance)->step_func = value;
            }
        }

        public int StepRate
        {
            get
            {
                return ((__Internal*)__Instance)->step_rate;
            }

            set
            {
                ((__Internal*)__Instance)->step_rate = value;
            }
        }
    }

    public unsafe partial class SgVertexAttrDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal int buffer_index;
            internal int offset;
            internal global::Sokol.SgVertexFormat format;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_vertex_attr_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgVertexAttrDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgVertexAttrDesc>();

        protected bool __ownsNativeInstance;

        internal static SgVertexAttrDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgVertexAttrDesc(native.ToPointer(), skipVTables);
        }

        internal static SgVertexAttrDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgVertexAttrDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgVertexAttrDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgVertexAttrDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgVertexAttrDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgVertexAttrDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgVertexAttrDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgVertexAttrDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgVertexAttrDesc(global::Sokol.SgVertexAttrDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgVertexAttrDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgVertexAttrDesc.__Internal*) __Instance) = *((global::Sokol.SgVertexAttrDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int BufferIndex
        {
            get
            {
                return ((__Internal*)__Instance)->buffer_index;
            }

            set
            {
                ((__Internal*)__Instance)->buffer_index = value;
            }
        }

        public int Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        public global::Sokol.SgVertexFormat Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }
    }

    public unsafe partial class SgLayoutDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 288)]
        public partial struct __Internal
        {
            internal fixed byte buffers[96];
            internal fixed byte attrs[192];

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_layout_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgLayoutDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgLayoutDesc>();

        protected bool __ownsNativeInstance;

        internal static SgLayoutDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgLayoutDesc(native.ToPointer(), skipVTables);
        }

        internal static SgLayoutDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgLayoutDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgLayoutDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgLayoutDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgLayoutDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgLayoutDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgLayoutDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgLayoutDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgLayoutDesc(global::Sokol.SgLayoutDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgLayoutDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgLayoutDesc.__Internal*) __Instance) = *((global::Sokol.SgLayoutDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgBufferLayoutDesc[] Buffers
        {
            get
            {
                global::Sokol.SgBufferLayoutDesc[] __value = null;
                if (((__Internal*)__Instance)->buffers != null)
                {
                    __value = new global::Sokol.SgBufferLayoutDesc[8];
                    for (int i = 0; i < 8; i++)
                        __value[i] = global::Sokol.SgBufferLayoutDesc.__GetOrCreateInstance((IntPtr)((global::Sokol.SgBufferLayoutDesc.__Internal*)&(((__Internal*)__Instance)->buffers[i * sizeof(global::Sokol.SgBufferLayoutDesc.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 8)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 8; i++)
                        *(global::Sokol.SgBufferLayoutDesc.__Internal*) &((__Internal*)__Instance)->buffers[i * sizeof(global::Sokol.SgBufferLayoutDesc.__Internal)] = *(global::Sokol.SgBufferLayoutDesc.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::Sokol.SgVertexAttrDesc[] Attrs
        {
            get
            {
                global::Sokol.SgVertexAttrDesc[] __value = null;
                if (((__Internal*)__Instance)->attrs != null)
                {
                    __value = new global::Sokol.SgVertexAttrDesc[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = global::Sokol.SgVertexAttrDesc.__GetOrCreateInstance((IntPtr)((global::Sokol.SgVertexAttrDesc.__Internal*)&(((__Internal*)__Instance)->attrs[i * sizeof(global::Sokol.SgVertexAttrDesc.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 16)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 16; i++)
                        *(global::Sokol.SgVertexAttrDesc.__Internal*) &((__Internal*)__Instance)->attrs[i * sizeof(global::Sokol.SgVertexAttrDesc.__Internal)] = *(global::Sokol.SgVertexAttrDesc.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class SgStencilFaceState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::Sokol.SgCompareFunc compare;
            internal global::Sokol.SgStencilOp fail_op;
            internal global::Sokol.SgStencilOp depth_fail_op;
            internal global::Sokol.SgStencilOp pass_op;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_stencil_face_state@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgStencilFaceState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgStencilFaceState>();

        protected bool __ownsNativeInstance;

        internal static SgStencilFaceState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgStencilFaceState(native.ToPointer(), skipVTables);
        }

        internal static SgStencilFaceState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgStencilFaceState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgStencilFaceState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgStencilFaceState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgStencilFaceState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgStencilFaceState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgStencilFaceState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgStencilFaceState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgStencilFaceState(global::Sokol.SgStencilFaceState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgStencilFaceState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgStencilFaceState.__Internal*) __Instance) = *((global::Sokol.SgStencilFaceState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgCompareFunc Compare
        {
            get
            {
                return ((__Internal*)__Instance)->compare;
            }

            set
            {
                ((__Internal*)__Instance)->compare = value;
            }
        }

        public global::Sokol.SgStencilOp FailOp
        {
            get
            {
                return ((__Internal*)__Instance)->fail_op;
            }

            set
            {
                ((__Internal*)__Instance)->fail_op = value;
            }
        }

        public global::Sokol.SgStencilOp DepthFailOp
        {
            get
            {
                return ((__Internal*)__Instance)->depth_fail_op;
            }

            set
            {
                ((__Internal*)__Instance)->depth_fail_op = value;
            }
        }

        public global::Sokol.SgStencilOp PassOp
        {
            get
            {
                return ((__Internal*)__Instance)->pass_op;
            }

            set
            {
                ((__Internal*)__Instance)->pass_op = value;
            }
        }
    }

    public unsafe partial class SgStencilState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal byte enabled;
            internal global::Sokol.SgStencilFaceState.__Internal front;
            internal global::Sokol.SgStencilFaceState.__Internal back;
            internal byte read_mask;
            internal byte write_mask;
            internal byte @ref;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_stencil_state@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgStencilState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgStencilState>();

        protected bool __ownsNativeInstance;

        internal static SgStencilState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgStencilState(native.ToPointer(), skipVTables);
        }

        internal static SgStencilState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgStencilState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgStencilState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgStencilState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgStencilState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgStencilState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgStencilState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgStencilState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgStencilState(global::Sokol.SgStencilState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgStencilState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgStencilState.__Internal*) __Instance) = *((global::Sokol.SgStencilState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Enabled
        {
            get
            {
                return ((__Internal*)__Instance)->enabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->enabled = (byte) (value ? 1 : 0);
            }
        }

        public global::Sokol.SgStencilFaceState Front
        {
            get
            {
                return global::Sokol.SgStencilFaceState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->front));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->front = *(global::Sokol.SgStencilFaceState.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SgStencilFaceState Back
        {
            get
            {
                return global::Sokol.SgStencilFaceState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->back));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->back = *(global::Sokol.SgStencilFaceState.__Internal*) value.__Instance;
            }
        }

        public byte ReadMask
        {
            get
            {
                return ((__Internal*)__Instance)->read_mask;
            }

            set
            {
                ((__Internal*)__Instance)->read_mask = value;
            }
        }

        public byte WriteMask
        {
            get
            {
                return ((__Internal*)__Instance)->write_mask;
            }

            set
            {
                ((__Internal*)__Instance)->write_mask = value;
            }
        }

        public byte Ref
        {
            get
            {
                return ((__Internal*)__Instance)->@ref;
            }

            set
            {
                ((__Internal*)__Instance)->@ref = value;
            }
        }
    }

    public unsafe partial class SgDepthState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::Sokol.SgPixelFormat pixel_format;
            internal global::Sokol.SgCompareFunc compare;
            internal byte write_enabled;
            internal float bias;
            internal float bias_slope_scale;
            internal float bias_clamp;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_depth_state@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgDepthState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgDepthState>();

        protected bool __ownsNativeInstance;

        internal static SgDepthState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgDepthState(native.ToPointer(), skipVTables);
        }

        internal static SgDepthState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgDepthState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgDepthState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgDepthState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgDepthState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgDepthState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgDepthState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgDepthState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgDepthState(global::Sokol.SgDepthState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgDepthState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgDepthState.__Internal*) __Instance) = *((global::Sokol.SgDepthState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgPixelFormat PixelFormat
        {
            get
            {
                return ((__Internal*)__Instance)->pixel_format;
            }

            set
            {
                ((__Internal*)__Instance)->pixel_format = value;
            }
        }

        public global::Sokol.SgCompareFunc Compare
        {
            get
            {
                return ((__Internal*)__Instance)->compare;
            }

            set
            {
                ((__Internal*)__Instance)->compare = value;
            }
        }

        public bool WriteEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->write_enabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->write_enabled = (byte) (value ? 1 : 0);
            }
        }

        public float Bias
        {
            get
            {
                return ((__Internal*)__Instance)->bias;
            }

            set
            {
                ((__Internal*)__Instance)->bias = value;
            }
        }

        public float BiasSlopeScale
        {
            get
            {
                return ((__Internal*)__Instance)->bias_slope_scale;
            }

            set
            {
                ((__Internal*)__Instance)->bias_slope_scale = value;
            }
        }

        public float BiasClamp
        {
            get
            {
                return ((__Internal*)__Instance)->bias_clamp;
            }

            set
            {
                ((__Internal*)__Instance)->bias_clamp = value;
            }
        }
    }

    public unsafe partial class SgBlendState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal byte enabled;
            internal global::Sokol.SgBlendFactor src_factor_rgb;
            internal global::Sokol.SgBlendFactor dst_factor_rgb;
            internal global::Sokol.SgBlendOp op_rgb;
            internal global::Sokol.SgBlendFactor src_factor_alpha;
            internal global::Sokol.SgBlendFactor dst_factor_alpha;
            internal global::Sokol.SgBlendOp op_alpha;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_blend_state@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBlendState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBlendState>();

        protected bool __ownsNativeInstance;

        internal static SgBlendState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgBlendState(native.ToPointer(), skipVTables);
        }

        internal static SgBlendState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgBlendState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgBlendState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgBlendState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgBlendState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgBlendState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgBlendState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBlendState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgBlendState(global::Sokol.SgBlendState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBlendState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgBlendState.__Internal*) __Instance) = *((global::Sokol.SgBlendState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Enabled
        {
            get
            {
                return ((__Internal*)__Instance)->enabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->enabled = (byte) (value ? 1 : 0);
            }
        }

        public global::Sokol.SgBlendFactor SrcFactorRgb
        {
            get
            {
                return ((__Internal*)__Instance)->src_factor_rgb;
            }

            set
            {
                ((__Internal*)__Instance)->src_factor_rgb = value;
            }
        }

        public global::Sokol.SgBlendFactor DstFactorRgb
        {
            get
            {
                return ((__Internal*)__Instance)->dst_factor_rgb;
            }

            set
            {
                ((__Internal*)__Instance)->dst_factor_rgb = value;
            }
        }

        public global::Sokol.SgBlendOp OpRgb
        {
            get
            {
                return ((__Internal*)__Instance)->op_rgb;
            }

            set
            {
                ((__Internal*)__Instance)->op_rgb = value;
            }
        }

        public global::Sokol.SgBlendFactor SrcFactorAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->src_factor_alpha;
            }

            set
            {
                ((__Internal*)__Instance)->src_factor_alpha = value;
            }
        }

        public global::Sokol.SgBlendFactor DstFactorAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->dst_factor_alpha;
            }

            set
            {
                ((__Internal*)__Instance)->dst_factor_alpha = value;
            }
        }

        public global::Sokol.SgBlendOp OpAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->op_alpha;
            }

            set
            {
                ((__Internal*)__Instance)->op_alpha = value;
            }
        }
    }

    public unsafe partial class SgColorState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 36)]
        public partial struct __Internal
        {
            internal global::Sokol.SgPixelFormat pixel_format;
            internal global::Sokol.SgColorMask write_mask;
            internal global::Sokol.SgBlendState.__Internal blend;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_color_state@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgColorState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgColorState>();

        protected bool __ownsNativeInstance;

        internal static SgColorState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgColorState(native.ToPointer(), skipVTables);
        }

        internal static SgColorState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgColorState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgColorState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgColorState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgColorState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgColorState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgColorState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgColorState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgColorState(global::Sokol.SgColorState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgColorState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgColorState.__Internal*) __Instance) = *((global::Sokol.SgColorState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgPixelFormat PixelFormat
        {
            get
            {
                return ((__Internal*)__Instance)->pixel_format;
            }

            set
            {
                ((__Internal*)__Instance)->pixel_format = value;
            }
        }

        public global::Sokol.SgColorMask WriteMask
        {
            get
            {
                return ((__Internal*)__Instance)->write_mask;
            }

            set
            {
                ((__Internal*)__Instance)->write_mask = value;
            }
        }

        public global::Sokol.SgBlendState Blend
        {
            get
            {
                return global::Sokol.SgBlendState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->blend));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->blend = *(global::Sokol.SgBlendState.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class SgPipelineDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 568)]
        public partial struct __Internal
        {
            internal uint _start_canary;
            internal global::Sokol.SgShader.__Internal shader;
            internal global::Sokol.SgLayoutDesc.__Internal layout;
            internal global::Sokol.SgDepthState.__Internal depth;
            internal global::Sokol.SgStencilState.__Internal stencil;
            internal int color_count;
            internal fixed byte colors[144];
            internal global::Sokol.SgPrimitiveType primitive_type;
            internal global::Sokol.SgIndexType index_type;
            internal global::Sokol.SgCullMode cull_mode;
            internal global::Sokol.SgFaceWinding face_winding;
            internal int sample_count;
            internal global::Sokol.SgColor.__Internal blend_color;
            internal byte alpha_to_coverage_enabled;
            internal __IntPtr label;
            internal uint _end_canary;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_pipeline_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPipelineDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPipelineDesc>();

        private bool __label_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SgPipelineDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgPipelineDesc(native.ToPointer(), skipVTables);
        }

        internal static SgPipelineDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgPipelineDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgPipelineDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgPipelineDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgPipelineDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgPipelineDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgPipelineDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPipelineDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgPipelineDesc(global::Sokol.SgPipelineDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPipelineDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgPipelineDesc.__Internal*) __Instance) = *((global::Sokol.SgPipelineDesc.__Internal*) _0.__Instance);
            if (_0.__label_OwnsNativeMemory)
                this.Label = _0.Label;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__label_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->label);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint StartCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_start_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_start_canary = value;
            }
        }

        public global::Sokol.SgShader Shader
        {
            get
            {
                return global::Sokol.SgShader.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->shader));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->shader = *(global::Sokol.SgShader.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SgLayoutDesc Layout
        {
            get
            {
                return global::Sokol.SgLayoutDesc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->layout));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->layout = *(global::Sokol.SgLayoutDesc.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SgDepthState Depth
        {
            get
            {
                return global::Sokol.SgDepthState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->depth));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->depth = *(global::Sokol.SgDepthState.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SgStencilState Stencil
        {
            get
            {
                return global::Sokol.SgStencilState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->stencil));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->stencil = *(global::Sokol.SgStencilState.__Internal*) value.__Instance;
            }
        }

        public int ColorCount
        {
            get
            {
                return ((__Internal*)__Instance)->color_count;
            }

            set
            {
                ((__Internal*)__Instance)->color_count = value;
            }
        }

        public global::Sokol.SgColorState[] Colors
        {
            get
            {
                global::Sokol.SgColorState[] __value = null;
                if (((__Internal*)__Instance)->colors != null)
                {
                    __value = new global::Sokol.SgColorState[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = global::Sokol.SgColorState.__GetOrCreateInstance((IntPtr)((global::Sokol.SgColorState.__Internal*)&(((__Internal*)__Instance)->colors[i * sizeof(global::Sokol.SgColorState.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 4)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 4; i++)
                        *(global::Sokol.SgColorState.__Internal*) &((__Internal*)__Instance)->colors[i * sizeof(global::Sokol.SgColorState.__Internal)] = *(global::Sokol.SgColorState.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::Sokol.SgPrimitiveType PrimitiveType
        {
            get
            {
                return ((__Internal*)__Instance)->primitive_type;
            }

            set
            {
                ((__Internal*)__Instance)->primitive_type = value;
            }
        }

        public global::Sokol.SgIndexType IndexType
        {
            get
            {
                return ((__Internal*)__Instance)->index_type;
            }

            set
            {
                ((__Internal*)__Instance)->index_type = value;
            }
        }

        public global::Sokol.SgCullMode CullMode
        {
            get
            {
                return ((__Internal*)__Instance)->cull_mode;
            }

            set
            {
                ((__Internal*)__Instance)->cull_mode = value;
            }
        }

        public global::Sokol.SgFaceWinding FaceWinding
        {
            get
            {
                return ((__Internal*)__Instance)->face_winding;
            }

            set
            {
                ((__Internal*)__Instance)->face_winding = value;
            }
        }

        public int SampleCount
        {
            get
            {
                return ((__Internal*)__Instance)->sample_count;
            }

            set
            {
                ((__Internal*)__Instance)->sample_count = value;
            }
        }

        public global::Sokol.SgColor BlendColor
        {
            get
            {
                return global::Sokol.SgColor.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->blend_color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->blend_color = *(global::Sokol.SgColor.__Internal*) value.__Instance;
            }
        }

        public bool AlphaToCoverageEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->alpha_to_coverage_enabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->alpha_to_coverage_enabled = (byte) (value ? 1 : 0);
            }
        }

        public string Label
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->label);
            }

            set
            {
                if (__label_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->label);
                __label_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->label = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->label = (__IntPtr) __bytePtr0;
            }
        }

        public uint EndCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_end_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_end_canary = value;
            }
        }
    }

    public unsafe partial class SgPassAttachmentDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::Sokol.SgImage.__Internal image;
            internal int mip_level;
            internal int slice;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_pass_attachment_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPassAttachmentDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPassAttachmentDesc>();

        protected bool __ownsNativeInstance;

        internal static SgPassAttachmentDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgPassAttachmentDesc(native.ToPointer(), skipVTables);
        }

        internal static SgPassAttachmentDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgPassAttachmentDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgPassAttachmentDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgPassAttachmentDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgPassAttachmentDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgPassAttachmentDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgPassAttachmentDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPassAttachmentDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgPassAttachmentDesc(global::Sokol.SgPassAttachmentDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPassAttachmentDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgPassAttachmentDesc.__Internal*) __Instance) = *((global::Sokol.SgPassAttachmentDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgImage Image
        {
            get
            {
                return global::Sokol.SgImage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->image));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->image = *(global::Sokol.SgImage.__Internal*) value.__Instance;
            }
        }

        public int MipLevel
        {
            get
            {
                return ((__Internal*)__Instance)->mip_level;
            }

            set
            {
                ((__Internal*)__Instance)->mip_level = value;
            }
        }

        public int Slice
        {
            get
            {
                return ((__Internal*)__Instance)->slice;
            }

            set
            {
                ((__Internal*)__Instance)->slice = value;
            }
        }
    }

    public unsafe partial class SgPassDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80)]
        public partial struct __Internal
        {
            internal uint _start_canary;
            internal fixed byte color_attachments[48];
            internal global::Sokol.SgPassAttachmentDesc.__Internal depth_stencil_attachment;
            internal __IntPtr label;
            internal uint _end_canary;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_pass_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPassDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPassDesc>();

        private bool __label_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SgPassDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgPassDesc(native.ToPointer(), skipVTables);
        }

        internal static SgPassDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgPassDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgPassDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgPassDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgPassDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgPassDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgPassDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPassDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgPassDesc(global::Sokol.SgPassDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPassDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgPassDesc.__Internal*) __Instance) = *((global::Sokol.SgPassDesc.__Internal*) _0.__Instance);
            if (_0.__label_OwnsNativeMemory)
                this.Label = _0.Label;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__label_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->label);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint StartCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_start_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_start_canary = value;
            }
        }

        public global::Sokol.SgPassAttachmentDesc[] ColorAttachments
        {
            get
            {
                global::Sokol.SgPassAttachmentDesc[] __value = null;
                if (((__Internal*)__Instance)->color_attachments != null)
                {
                    __value = new global::Sokol.SgPassAttachmentDesc[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = global::Sokol.SgPassAttachmentDesc.__GetOrCreateInstance((IntPtr)((global::Sokol.SgPassAttachmentDesc.__Internal*)&(((__Internal*)__Instance)->color_attachments[i * sizeof(global::Sokol.SgPassAttachmentDesc.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 4)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 4; i++)
                        *(global::Sokol.SgPassAttachmentDesc.__Internal*) &((__Internal*)__Instance)->color_attachments[i * sizeof(global::Sokol.SgPassAttachmentDesc.__Internal)] = *(global::Sokol.SgPassAttachmentDesc.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::Sokol.SgPassAttachmentDesc DepthStencilAttachment
        {
            get
            {
                return global::Sokol.SgPassAttachmentDesc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->depth_stencil_attachment));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->depth_stencil_attachment = *(global::Sokol.SgPassAttachmentDesc.__Internal*) value.__Instance;
            }
        }

        public string Label
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->label);
            }

            set
            {
                if (__label_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->label);
                __label_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->label = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->label = (__IntPtr) __bytePtr0;
            }
        }

        public uint EndCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_end_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_end_canary = value;
            }
        }
    }

    public unsafe partial class SgTraceHooks : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 488)]
        public partial struct __Internal
        {
            internal __IntPtr user_data;
            internal __IntPtr reset_state_cache;
            internal __IntPtr make_buffer;
            internal __IntPtr make_image;
            internal __IntPtr make_shader;
            internal __IntPtr make_pipeline;
            internal __IntPtr make_pass;
            internal __IntPtr destroy_buffer;
            internal __IntPtr destroy_image;
            internal __IntPtr destroy_shader;
            internal __IntPtr destroy_pipeline;
            internal __IntPtr destroy_pass;
            internal __IntPtr update_buffer;
            internal __IntPtr update_image;
            internal __IntPtr append_buffer;
            internal __IntPtr begin_default_pass;
            internal __IntPtr begin_pass;
            internal __IntPtr apply_viewport;
            internal __IntPtr apply_scissor_rect;
            internal __IntPtr apply_pipeline;
            internal __IntPtr apply_bindings;
            internal __IntPtr apply_uniforms;
            internal __IntPtr draw;
            internal __IntPtr end_pass;
            internal __IntPtr commit;
            internal __IntPtr alloc_buffer;
            internal __IntPtr alloc_image;
            internal __IntPtr alloc_shader;
            internal __IntPtr alloc_pipeline;
            internal __IntPtr alloc_pass;
            internal __IntPtr dealloc_buffer;
            internal __IntPtr dealloc_image;
            internal __IntPtr dealloc_shader;
            internal __IntPtr dealloc_pipeline;
            internal __IntPtr dealloc_pass;
            internal __IntPtr init_buffer;
            internal __IntPtr init_image;
            internal __IntPtr init_shader;
            internal __IntPtr init_pipeline;
            internal __IntPtr init_pass;
            internal __IntPtr uninit_buffer;
            internal __IntPtr uninit_image;
            internal __IntPtr uninit_shader;
            internal __IntPtr uninit_pipeline;
            internal __IntPtr uninit_pass;
            internal __IntPtr fail_buffer;
            internal __IntPtr fail_image;
            internal __IntPtr fail_shader;
            internal __IntPtr fail_pipeline;
            internal __IntPtr fail_pass;
            internal __IntPtr push_debug_group;
            internal __IntPtr pop_debug_group;
            internal __IntPtr err_buffer_pool_exhausted;
            internal __IntPtr err_image_pool_exhausted;
            internal __IntPtr err_shader_pool_exhausted;
            internal __IntPtr err_pipeline_pool_exhausted;
            internal __IntPtr err_pass_pool_exhausted;
            internal __IntPtr err_context_mismatch;
            internal __IntPtr err_pass_invalid;
            internal __IntPtr err_draw_invalid;
            internal __IntPtr err_bindings_invalid;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_trace_hooks@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgTraceHooks> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgTraceHooks>();

        protected bool __ownsNativeInstance;

        internal static SgTraceHooks __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgTraceHooks(native.ToPointer(), skipVTables);
        }

        internal static SgTraceHooks __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgTraceHooks)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgTraceHooks __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgTraceHooks(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgTraceHooks(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgTraceHooks(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgTraceHooks()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgTraceHooks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgTraceHooks(global::Sokol.SgTraceHooks _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgTraceHooks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgTraceHooks.__Internal*) __Instance) = *((global::Sokol.SgTraceHooks.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        public global::Sokol.Delegates.Action___IntPtr ResetStateCache
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->reset_state_cache;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->reset_state_cache = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr_Sokol_sg_buffer___Internal___IntPtr MakeBuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->make_buffer;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr_Sokol_sg_buffer___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr_Sokol_sg_buffer___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->make_buffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr_Sokol_sg_image___Internal___IntPtr MakeImage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->make_image;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr_Sokol_sg_image___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr_Sokol_sg_image___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->make_image = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr_Sokol_sg_shader___Internal___IntPtr MakeShader
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->make_shader;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr_Sokol_sg_shader___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr_Sokol_sg_shader___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->make_shader = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr_Sokol_sg_pipeline___Internal___IntPtr MakePipeline
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->make_pipeline;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr_Sokol_sg_pipeline___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr_Sokol_sg_pipeline___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->make_pipeline = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr_Sokol_sg_pass___Internal___IntPtr MakePass
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->make_pass;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr_Sokol_sg_pass___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr_Sokol_sg_pass___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->make_pass = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr DestroyBuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->destroy_buffer;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->destroy_buffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr DestroyImage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->destroy_image;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->destroy_image = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr DestroyShader
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->destroy_shader;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->destroy_shader = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr DestroyPipeline
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->destroy_pipeline;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->destroy_pipeline = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr DestroyPass
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->destroy_pass;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->destroy_pass = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr___IntPtr UpdateBuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->update_buffer;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->update_buffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr___IntPtr UpdateImage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->update_image;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->update_image = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr_int___IntPtr AppendBuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->append_buffer;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr_int___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr_int___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->append_buffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr_int_int___IntPtr BeginDefaultPass
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->begin_default_pass;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr_int_int___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr_int_int___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->begin_default_pass = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr___IntPtr BeginPass
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->begin_pass;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->begin_pass = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_int_int_int_int_bool___IntPtr ApplyViewport
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->apply_viewport;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_int_int_int_int_bool___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_int_int_int_int_bool___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->apply_viewport = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_int_int_int_int_bool___IntPtr ApplyScissorRect
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->apply_scissor_rect;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_int_int_int_int_bool___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_int_int_int_int_bool___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->apply_scissor_rect = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr ApplyPipeline
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->apply_pipeline;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->apply_pipeline = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr___IntPtr ApplyBindings
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->apply_bindings;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->apply_bindings = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_shader_stage_int___IntPtr___IntPtr ApplyUniforms
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->apply_uniforms;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_shader_stage_int___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_shader_stage_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->apply_uniforms = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_int_int_int___IntPtr Draw
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->draw;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_int_int_int___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_int_int_int___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->draw = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr EndPass
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->end_pass;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->end_pass = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr Commit
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->commit;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->commit = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr AllocBuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->alloc_buffer;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->alloc_buffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr AllocImage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->alloc_image;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->alloc_image = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr AllocShader
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->alloc_shader;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->alloc_shader = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr AllocPipeline
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->alloc_pipeline;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->alloc_pipeline = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr AllocPass
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->alloc_pass;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->alloc_pass = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr DeallocBuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dealloc_buffer;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->dealloc_buffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr DeallocImage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dealloc_image;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->dealloc_image = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr DeallocShader
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dealloc_shader;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->dealloc_shader = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr DeallocPipeline
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dealloc_pipeline;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->dealloc_pipeline = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr DeallocPass
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dealloc_pass;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->dealloc_pass = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr___IntPtr InitBuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->init_buffer;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->init_buffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr___IntPtr InitImage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->init_image;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->init_image = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr___IntPtr InitShader
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->init_shader;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->init_shader = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr___IntPtr InitPipeline
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->init_pipeline;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->init_pipeline = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr___IntPtr InitPass
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->init_pass;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->init_pass = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr UninitBuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->uninit_buffer;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->uninit_buffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr UninitImage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->uninit_image;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->uninit_image = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr UninitShader
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->uninit_shader;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->uninit_shader = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr UninitPipeline
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->uninit_pipeline;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->uninit_pipeline = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr UninitPass
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->uninit_pass;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->uninit_pass = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr FailBuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->fail_buffer;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_buffer___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->fail_buffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr FailImage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->fail_image;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_image___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->fail_image = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr FailShader
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->fail_shader;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_shader___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->fail_shader = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr FailPipeline
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->fail_pipeline;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pipeline___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->fail_pipeline = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr FailPass
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->fail_pass;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_Sokol_sg_pass___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->fail_pass = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action_string8___IntPtr PushDebugGroup
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->push_debug_group;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action_string8___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action_string8___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->push_debug_group = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr PopDebugGroup
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->pop_debug_group;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->pop_debug_group = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr ErrBufferPoolExhausted
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->err_buffer_pool_exhausted;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->err_buffer_pool_exhausted = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr ErrImagePoolExhausted
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->err_image_pool_exhausted;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->err_image_pool_exhausted = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr ErrShaderPoolExhausted
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->err_shader_pool_exhausted;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->err_shader_pool_exhausted = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr ErrPipelinePoolExhausted
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->err_pipeline_pool_exhausted;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->err_pipeline_pool_exhausted = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr ErrPassPoolExhausted
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->err_pass_pool_exhausted;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->err_pass_pool_exhausted = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr ErrContextMismatch
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->err_context_mismatch;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->err_context_mismatch = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr ErrPassInvalid
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->err_pass_invalid;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->err_pass_invalid = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr ErrDrawInvalid
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->err_draw_invalid;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->err_draw_invalid = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr ErrBindingsInvalid
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->err_bindings_invalid;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->err_bindings_invalid = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class SgSlotInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::Sokol.SgResourceState state;
            internal uint res_id;
            internal uint ctx_id;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_slot_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgSlotInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgSlotInfo>();

        protected bool __ownsNativeInstance;

        internal static SgSlotInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgSlotInfo(native.ToPointer(), skipVTables);
        }

        internal static SgSlotInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgSlotInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgSlotInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgSlotInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgSlotInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgSlotInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgSlotInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgSlotInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgSlotInfo(global::Sokol.SgSlotInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgSlotInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgSlotInfo.__Internal*) __Instance) = *((global::Sokol.SgSlotInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgResourceState State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        public uint ResId
        {
            get
            {
                return ((__Internal*)__Instance)->res_id;
            }

            set
            {
                ((__Internal*)__Instance)->res_id = value;
            }
        }

        public uint CtxId
        {
            get
            {
                return ((__Internal*)__Instance)->ctx_id;
            }

            set
            {
                ((__Internal*)__Instance)->ctx_id = value;
            }
        }
    }

    public unsafe partial class SgBufferInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 36)]
        public partial struct __Internal
        {
            internal global::Sokol.SgSlotInfo.__Internal slot;
            internal uint update_frame_index;
            internal uint append_frame_index;
            internal int append_pos;
            internal byte append_overflow;
            internal int num_slots;
            internal int active_slot;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_buffer_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBufferInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgBufferInfo>();

        protected bool __ownsNativeInstance;

        internal static SgBufferInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgBufferInfo(native.ToPointer(), skipVTables);
        }

        internal static SgBufferInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgBufferInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgBufferInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgBufferInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgBufferInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgBufferInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgBufferInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBufferInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgBufferInfo(global::Sokol.SgBufferInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgBufferInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgBufferInfo.__Internal*) __Instance) = *((global::Sokol.SgBufferInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgSlotInfo Slot
        {
            get
            {
                return global::Sokol.SgSlotInfo.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->slot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->slot = *(global::Sokol.SgSlotInfo.__Internal*) value.__Instance;
            }
        }

        public uint UpdateFrameIndex
        {
            get
            {
                return ((__Internal*)__Instance)->update_frame_index;
            }

            set
            {
                ((__Internal*)__Instance)->update_frame_index = value;
            }
        }

        public uint AppendFrameIndex
        {
            get
            {
                return ((__Internal*)__Instance)->append_frame_index;
            }

            set
            {
                ((__Internal*)__Instance)->append_frame_index = value;
            }
        }

        public int AppendPos
        {
            get
            {
                return ((__Internal*)__Instance)->append_pos;
            }

            set
            {
                ((__Internal*)__Instance)->append_pos = value;
            }
        }

        public bool AppendOverflow
        {
            get
            {
                return ((__Internal*)__Instance)->append_overflow != 0;
            }

            set
            {
                ((__Internal*)__Instance)->append_overflow = (byte) (value ? 1 : 0);
            }
        }

        public int NumSlots
        {
            get
            {
                return ((__Internal*)__Instance)->num_slots;
            }

            set
            {
                ((__Internal*)__Instance)->num_slots = value;
            }
        }

        public int ActiveSlot
        {
            get
            {
                return ((__Internal*)__Instance)->active_slot;
            }

            set
            {
                ((__Internal*)__Instance)->active_slot = value;
            }
        }
    }

    public unsafe partial class SgImageInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::Sokol.SgSlotInfo.__Internal slot;
            internal uint upd_frame_index;
            internal int num_slots;
            internal int active_slot;
            internal int width;
            internal int height;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_image_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgImageInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgImageInfo>();

        protected bool __ownsNativeInstance;

        internal static SgImageInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgImageInfo(native.ToPointer(), skipVTables);
        }

        internal static SgImageInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgImageInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgImageInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgImageInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgImageInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgImageInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgImageInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgImageInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgImageInfo(global::Sokol.SgImageInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgImageInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgImageInfo.__Internal*) __Instance) = *((global::Sokol.SgImageInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgSlotInfo Slot
        {
            get
            {
                return global::Sokol.SgSlotInfo.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->slot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->slot = *(global::Sokol.SgSlotInfo.__Internal*) value.__Instance;
            }
        }

        public uint UpdFrameIndex
        {
            get
            {
                return ((__Internal*)__Instance)->upd_frame_index;
            }

            set
            {
                ((__Internal*)__Instance)->upd_frame_index = value;
            }
        }

        public int NumSlots
        {
            get
            {
                return ((__Internal*)__Instance)->num_slots;
            }

            set
            {
                ((__Internal*)__Instance)->num_slots = value;
            }
        }

        public int ActiveSlot
        {
            get
            {
                return ((__Internal*)__Instance)->active_slot;
            }

            set
            {
                ((__Internal*)__Instance)->active_slot = value;
            }
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }
    }

    public unsafe partial class SgShaderInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::Sokol.SgSlotInfo.__Internal slot;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_shader_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgShaderInfo>();

        protected bool __ownsNativeInstance;

        internal static SgShaderInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgShaderInfo(native.ToPointer(), skipVTables);
        }

        internal static SgShaderInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgShaderInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgShaderInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgShaderInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgShaderInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgShaderInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgShaderInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgShaderInfo(global::Sokol.SgShaderInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgShaderInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgShaderInfo.__Internal*) __Instance) = *((global::Sokol.SgShaderInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgSlotInfo Slot
        {
            get
            {
                return global::Sokol.SgSlotInfo.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->slot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->slot = *(global::Sokol.SgSlotInfo.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class SgPipelineInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::Sokol.SgSlotInfo.__Internal slot;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_pipeline_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPipelineInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPipelineInfo>();

        protected bool __ownsNativeInstance;

        internal static SgPipelineInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgPipelineInfo(native.ToPointer(), skipVTables);
        }

        internal static SgPipelineInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgPipelineInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgPipelineInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgPipelineInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgPipelineInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgPipelineInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgPipelineInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPipelineInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgPipelineInfo(global::Sokol.SgPipelineInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPipelineInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgPipelineInfo.__Internal*) __Instance) = *((global::Sokol.SgPipelineInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgSlotInfo Slot
        {
            get
            {
                return global::Sokol.SgSlotInfo.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->slot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->slot = *(global::Sokol.SgSlotInfo.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class SgPassInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::Sokol.SgSlotInfo.__Internal slot;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_pass_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPassInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgPassInfo>();

        protected bool __ownsNativeInstance;

        internal static SgPassInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgPassInfo(native.ToPointer(), skipVTables);
        }

        internal static SgPassInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgPassInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgPassInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgPassInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgPassInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgPassInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgPassInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPassInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgPassInfo(global::Sokol.SgPassInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgPassInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgPassInfo.__Internal*) __Instance) = *((global::Sokol.SgPassInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgSlotInfo Slot
        {
            get
            {
                return global::Sokol.SgSlotInfo.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->slot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->slot = *(global::Sokol.SgSlotInfo.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class SgGlContextDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte force_gles2;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_gl_context_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgGlContextDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgGlContextDesc>();

        protected bool __ownsNativeInstance;

        internal static SgGlContextDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgGlContextDesc(native.ToPointer(), skipVTables);
        }

        internal static SgGlContextDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgGlContextDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgGlContextDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgGlContextDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgGlContextDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgGlContextDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgGlContextDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgGlContextDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgGlContextDesc(global::Sokol.SgGlContextDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgGlContextDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgGlContextDesc.__Internal*) __Instance) = *((global::Sokol.SgGlContextDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool ForceGles2
        {
            get
            {
                return ((__Internal*)__Instance)->force_gles2 != 0;
            }

            set
            {
                ((__Internal*)__Instance)->force_gles2 = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class SgMetalContextDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal __IntPtr device;
            internal __IntPtr renderpass_descriptor_cb;
            internal __IntPtr renderpass_descriptor_userdata_cb;
            internal __IntPtr drawable_cb;
            internal __IntPtr drawable_userdata_cb;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_metal_context_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgMetalContextDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgMetalContextDesc>();

        protected bool __ownsNativeInstance;

        internal static SgMetalContextDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgMetalContextDesc(native.ToPointer(), skipVTables);
        }

        internal static SgMetalContextDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgMetalContextDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgMetalContextDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgMetalContextDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgMetalContextDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgMetalContextDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgMetalContextDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgMetalContextDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgMetalContextDesc(global::Sokol.SgMetalContextDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgMetalContextDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgMetalContextDesc.__Internal*) __Instance) = *((global::Sokol.SgMetalContextDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Device
        {
            get
            {
                return ((__Internal*)__Instance)->device;
            }
        }

        public global::Sokol.Delegates.Func___IntPtr RenderpassDescriptorCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->renderpass_descriptor_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->renderpass_descriptor_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr___IntPtr RenderpassDescriptorUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->renderpass_descriptor_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->renderpass_descriptor_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr DrawableCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->drawable_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->drawable_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr___IntPtr DrawableUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->drawable_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->drawable_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class SgD3d11ContextDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal __IntPtr device;
            internal __IntPtr device_context;
            internal __IntPtr render_target_view_cb;
            internal __IntPtr render_target_view_userdata_cb;
            internal __IntPtr depth_stencil_view_cb;
            internal __IntPtr depth_stencil_view_userdata_cb;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_d3d11_context_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgD3d11ContextDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgD3d11ContextDesc>();

        protected bool __ownsNativeInstance;

        internal static SgD3d11ContextDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgD3d11ContextDesc(native.ToPointer(), skipVTables);
        }

        internal static SgD3d11ContextDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgD3d11ContextDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgD3d11ContextDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgD3d11ContextDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgD3d11ContextDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgD3d11ContextDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgD3d11ContextDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgD3d11ContextDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgD3d11ContextDesc(global::Sokol.SgD3d11ContextDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgD3d11ContextDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgD3d11ContextDesc.__Internal*) __Instance) = *((global::Sokol.SgD3d11ContextDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Device
        {
            get
            {
                return ((__Internal*)__Instance)->device;
            }
        }

        public __IntPtr DeviceContext
        {
            get
            {
                return ((__Internal*)__Instance)->device_context;
            }
        }

        public global::Sokol.Delegates.Func___IntPtr RenderTargetViewCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->render_target_view_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->render_target_view_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr___IntPtr RenderTargetViewUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->render_target_view_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->render_target_view_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr DepthStencilViewCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->depth_stencil_view_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->depth_stencil_view_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr___IntPtr DepthStencilViewUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->depth_stencil_view_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->depth_stencil_view_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class SgWgpuContextDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal __IntPtr device;
            internal __IntPtr render_view_cb;
            internal __IntPtr render_view_userdata_cb;
            internal __IntPtr resolve_view_cb;
            internal __IntPtr resolve_view_userdata_cb;
            internal __IntPtr depth_stencil_view_cb;
            internal __IntPtr depth_stencil_view_userdata_cb;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_wgpu_context_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgWgpuContextDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgWgpuContextDesc>();

        protected bool __ownsNativeInstance;

        internal static SgWgpuContextDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgWgpuContextDesc(native.ToPointer(), skipVTables);
        }

        internal static SgWgpuContextDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgWgpuContextDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgWgpuContextDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgWgpuContextDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgWgpuContextDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgWgpuContextDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgWgpuContextDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgWgpuContextDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgWgpuContextDesc(global::Sokol.SgWgpuContextDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgWgpuContextDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgWgpuContextDesc.__Internal*) __Instance) = *((global::Sokol.SgWgpuContextDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Device
        {
            get
            {
                return ((__Internal*)__Instance)->device;
            }
        }

        public global::Sokol.Delegates.Func___IntPtr RenderViewCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->render_view_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->render_view_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr___IntPtr RenderViewUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->render_view_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->render_view_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr ResolveViewCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->resolve_view_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->resolve_view_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr___IntPtr ResolveViewUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->resolve_view_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->resolve_view_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr DepthStencilViewCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->depth_stencil_view_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->depth_stencil_view_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Func___IntPtr___IntPtr DepthStencilViewUserdataCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->depth_stencil_view_userdata_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->depth_stencil_view_userdata_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class SgContextDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 184)]
        public partial struct __Internal
        {
            internal global::Sokol.SgPixelFormat color_format;
            internal global::Sokol.SgPixelFormat depth_format;
            internal int sample_count;
            internal global::Sokol.SgGlContextDesc.__Internal gl;
            internal global::Sokol.SgMetalContextDesc.__Internal metal;
            internal global::Sokol.SgD3d11ContextDesc.__Internal d3d11;
            internal global::Sokol.SgWgpuContextDesc.__Internal wgpu;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_context_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgContextDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgContextDesc>();

        protected bool __ownsNativeInstance;

        internal static SgContextDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgContextDesc(native.ToPointer(), skipVTables);
        }

        internal static SgContextDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgContextDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgContextDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgContextDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgContextDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgContextDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgContextDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgContextDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgContextDesc(global::Sokol.SgContextDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgContextDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgContextDesc.__Internal*) __Instance) = *((global::Sokol.SgContextDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.SgPixelFormat ColorFormat
        {
            get
            {
                return ((__Internal*)__Instance)->color_format;
            }

            set
            {
                ((__Internal*)__Instance)->color_format = value;
            }
        }

        public global::Sokol.SgPixelFormat DepthFormat
        {
            get
            {
                return ((__Internal*)__Instance)->depth_format;
            }

            set
            {
                ((__Internal*)__Instance)->depth_format = value;
            }
        }

        public int SampleCount
        {
            get
            {
                return ((__Internal*)__Instance)->sample_count;
            }

            set
            {
                ((__Internal*)__Instance)->sample_count = value;
            }
        }

        public global::Sokol.SgGlContextDesc Gl
        {
            get
            {
                return global::Sokol.SgGlContextDesc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->gl));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->gl = *(global::Sokol.SgGlContextDesc.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SgMetalContextDesc Metal
        {
            get
            {
                return global::Sokol.SgMetalContextDesc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->metal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->metal = *(global::Sokol.SgMetalContextDesc.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SgD3d11ContextDesc D3d11
        {
            get
            {
                return global::Sokol.SgD3d11ContextDesc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->d3d11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->d3d11 = *(global::Sokol.SgD3d11ContextDesc.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SgWgpuContextDesc Wgpu
        {
            get
            {
                return global::Sokol.SgWgpuContextDesc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->wgpu));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->wgpu = *(global::Sokol.SgWgpuContextDesc.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class SgAllocator : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr alloc;
            internal __IntPtr free;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_allocator@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgAllocator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgAllocator>();

        protected bool __ownsNativeInstance;

        internal static SgAllocator __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgAllocator(native.ToPointer(), skipVTables);
        }

        internal static SgAllocator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgAllocator)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgAllocator __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgAllocator(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgAllocator(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgAllocator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgAllocator()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgAllocator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgAllocator(global::Sokol.SgAllocator _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgAllocator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgAllocator.__Internal*) __Instance) = *((global::Sokol.SgAllocator.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sokol.Delegates.Func___IntPtr_ulong___IntPtr Alloc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->alloc;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Func___IntPtr_ulong___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Func___IntPtr_ulong___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->alloc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sokol.Delegates.Action___IntPtr___IntPtr Free
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->free;
                return __ptr0 == IntPtr.Zero? null : (global::Sokol.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sokol.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->free = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class SgDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 256)]
        public partial struct __Internal
        {
            internal uint _start_canary;
            internal int buffer_pool_size;
            internal int image_pool_size;
            internal int shader_pool_size;
            internal int pipeline_pool_size;
            internal int pass_pool_size;
            internal int context_pool_size;
            internal int uniform_buffer_size;
            internal int staging_buffer_size;
            internal int sampler_cache_size;
            internal global::Sokol.SgAllocator.__Internal allocator;
            internal global::Sokol.SgContextDesc.__Internal context;
            internal uint _end_canary;

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "??0sg_desc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgDesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sokol.SgDesc>();

        protected bool __ownsNativeInstance;

        internal static SgDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SgDesc(native.ToPointer(), skipVTables);
        }

        internal static SgDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SgDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SgDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SgDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SgDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SgDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SgDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SgDesc(global::Sokol.SgDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sokol.SgDesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sokol.SgDesc.__Internal*) __Instance) = *((global::Sokol.SgDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint StartCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_start_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_start_canary = value;
            }
        }

        public int BufferPoolSize
        {
            get
            {
                return ((__Internal*)__Instance)->buffer_pool_size;
            }

            set
            {
                ((__Internal*)__Instance)->buffer_pool_size = value;
            }
        }

        public int ImagePoolSize
        {
            get
            {
                return ((__Internal*)__Instance)->image_pool_size;
            }

            set
            {
                ((__Internal*)__Instance)->image_pool_size = value;
            }
        }

        public int ShaderPoolSize
        {
            get
            {
                return ((__Internal*)__Instance)->shader_pool_size;
            }

            set
            {
                ((__Internal*)__Instance)->shader_pool_size = value;
            }
        }

        public int PipelinePoolSize
        {
            get
            {
                return ((__Internal*)__Instance)->pipeline_pool_size;
            }

            set
            {
                ((__Internal*)__Instance)->pipeline_pool_size = value;
            }
        }

        public int PassPoolSize
        {
            get
            {
                return ((__Internal*)__Instance)->pass_pool_size;
            }

            set
            {
                ((__Internal*)__Instance)->pass_pool_size = value;
            }
        }

        public int ContextPoolSize
        {
            get
            {
                return ((__Internal*)__Instance)->context_pool_size;
            }

            set
            {
                ((__Internal*)__Instance)->context_pool_size = value;
            }
        }

        public int UniformBufferSize
        {
            get
            {
                return ((__Internal*)__Instance)->uniform_buffer_size;
            }

            set
            {
                ((__Internal*)__Instance)->uniform_buffer_size = value;
            }
        }

        public int StagingBufferSize
        {
            get
            {
                return ((__Internal*)__Instance)->staging_buffer_size;
            }

            set
            {
                ((__Internal*)__Instance)->staging_buffer_size = value;
            }
        }

        public int SamplerCacheSize
        {
            get
            {
                return ((__Internal*)__Instance)->sampler_cache_size;
            }

            set
            {
                ((__Internal*)__Instance)->sampler_cache_size = value;
            }
        }

        public global::Sokol.SgAllocator Allocator
        {
            get
            {
                return global::Sokol.SgAllocator.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->allocator));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->allocator = *(global::Sokol.SgAllocator.__Internal*) value.__Instance;
            }
        }

        public global::Sokol.SgContextDesc Context
        {
            get
            {
                return global::Sokol.SgContextDesc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->context));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->context = *(global::Sokol.SgContextDesc.__Internal*) value.__Instance;
            }
        }

        public uint EndCanary
        {
            get
            {
                return ((__Internal*)__Instance)->_end_canary;
            }

            set
            {
                ((__Internal*)__Instance)->_end_canary = value;
            }
        }
    }

    public unsafe partial class sokol_gfx
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_shutdown", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgShutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_isvalid", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SgIsvalid();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_reset_state_cache", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgResetStateCache();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_install_trace_hooks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgInstallTraceHooks(__IntPtr @return, __IntPtr trace_hooks);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_push_debug_group", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgPushDebugGroup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_pop_debug_group", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgPopDebugGroup();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_destroy_buffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDestroyBuffer(global::Sokol.SgBuffer.__Internal buf);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_destroy_image", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDestroyImage(global::Sokol.SgImage.__Internal img);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_destroy_shader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDestroyShader(global::Sokol.SgShader.__Internal shd);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_destroy_pipeline", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDestroyPipeline(global::Sokol.SgPipeline.__Internal pip);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_destroy_pass", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDestroyPass(global::Sokol.SgPass.__Internal pass);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_buffer_overflow", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SgQueryBufferOverflow(global::Sokol.SgBuffer.__Internal buf);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_buffer_will_overflow", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SgQueryBufferWillOverflow(global::Sokol.SgBuffer.__Internal buf, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_apply_viewport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgApplyViewport(int x, int y, int width, int height, bool origin_top_left);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_apply_viewportf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgApplyViewportf(float x, float y, float width, float height, bool origin_top_left);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_apply_scissor_rect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgApplyScissorRect(int x, int y, int width, int height, bool origin_top_left);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_apply_scissor_rectf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgApplyScissorRectf(float x, float y, float width, float height, bool origin_top_left);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_apply_pipeline", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgApplyPipeline(global::Sokol.SgPipeline.__Internal pip);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_draw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDraw(int base_element, int num_elements, int num_instances);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_end_pass", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgEndPass();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_commit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgCommit();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_desc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryDesc(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_backend", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgBackend SgQueryBackend();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_features", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryFeatures(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_limits", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryLimits(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_pixelformat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryPixelformat(__IntPtr @return, global::Sokol.SgPixelFormat fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_buffer_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgResourceState SgQueryBufferState(global::Sokol.SgBuffer.__Internal buf);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_image_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgResourceState SgQueryImageState(global::Sokol.SgImage.__Internal img);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_shader_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgResourceState SgQueryShaderState(global::Sokol.SgShader.__Internal shd);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_pipeline_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgResourceState SgQueryPipelineState(global::Sokol.SgPipeline.__Internal pip);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_pass_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgResourceState SgQueryPassState(global::Sokol.SgPass.__Internal pass);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_buffer_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryBufferInfo(__IntPtr @return, global::Sokol.SgBuffer.__Internal buf);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_image_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryImageInfo(__IntPtr @return, global::Sokol.SgImage.__Internal img);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_shader_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryShaderInfo(__IntPtr @return, global::Sokol.SgShader.__Internal shd);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_pipeline_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryPipelineInfo(__IntPtr @return, global::Sokol.SgPipeline.__Internal pip);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_query_pass_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryPassInfo(__IntPtr @return, global::Sokol.SgPass.__Internal pass);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_alloc_buffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgBuffer.__Internal SgAllocBuffer();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_alloc_image", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgImage.__Internal SgAllocImage();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_alloc_shader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgShader.__Internal SgAllocShader();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_alloc_pipeline", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgPipeline.__Internal SgAllocPipeline();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_alloc_pass", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgPass.__Internal SgAllocPass();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_dealloc_buffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDeallocBuffer(global::Sokol.SgBuffer.__Internal buf_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_dealloc_image", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDeallocImage(global::Sokol.SgImage.__Internal img_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_dealloc_shader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDeallocShader(global::Sokol.SgShader.__Internal shd_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_dealloc_pipeline", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDeallocPipeline(global::Sokol.SgPipeline.__Internal pip_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_dealloc_pass", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDeallocPass(global::Sokol.SgPass.__Internal pass_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_uninit_buffer", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SgUninitBuffer(global::Sokol.SgBuffer.__Internal buf_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_uninit_image", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SgUninitImage(global::Sokol.SgImage.__Internal img_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_uninit_shader", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SgUninitShader(global::Sokol.SgShader.__Internal shd_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_uninit_pipeline", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SgUninitPipeline(global::Sokol.SgPipeline.__Internal pip_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_uninit_pass", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SgUninitPass(global::Sokol.SgPass.__Internal pass_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_fail_buffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgFailBuffer(global::Sokol.SgBuffer.__Internal buf_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_fail_image", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgFailImage(global::Sokol.SgImage.__Internal img_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_fail_shader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgFailShader(global::Sokol.SgShader.__Internal shd_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_fail_pipeline", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgFailPipeline(global::Sokol.SgPipeline.__Internal pip_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_fail_pass", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgFailPass(global::Sokol.SgPass.__Internal pass_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_setup_context", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgContext.__Internal SgSetupContext();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_activate_context", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgActivateContext(global::Sokol.SgContext.__Internal ctx_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_discard_context", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgDiscardContext(global::Sokol.SgContext.__Internal ctx_id);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_d3d11_device", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SgD3d11Device();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_mtl_device", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SgMtlDevice();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_mtl_render_command_encoder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SgMtlRenderCommandEncoder();

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_setup", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgSetup(__IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_make_buffer@@YA?AUsg_buffer@@AEBUsg_buffer_desc@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgBuffer.__Internal SgMakeBuffer(__IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_make_image@@YA?AUsg_image@@AEBUsg_image_desc@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgImage.__Internal SgMakeImage(__IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_make_shader@@YA?AUsg_shader@@AEBUsg_shader_desc@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgShader.__Internal SgMakeShader(__IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_make_pipeline@@YA?AUsg_pipeline@@AEBUsg_pipeline_desc@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgPipeline.__Internal SgMakePipeline(__IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_make_pass@@YA?AUsg_pass@@AEBUsg_pass_desc@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sokol.SgPass.__Internal SgMakePass(__IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_update_image@@YAXUsg_image@@AEBUsg_image_data@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgUpdateImage(global::Sokol.SgImage.__Internal img, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_begin_default_pass", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgBeginDefaultPass(__IntPtr pass_action, int width, int height);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_begin_default_passf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgBeginDefaultPassf(__IntPtr pass_action, float width, float height);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_begin_pass", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgBeginPass(global::Sokol.SgPass.__Internal pass, __IntPtr pass_action);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "sg_apply_bindings", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgApplyBindings(__IntPtr bindings);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_apply_uniforms@@YAXW4sg_shader_stage@@HAEBUsg_range@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgApplyUniforms(global::Sokol.SgShaderStage stage, int ub_index, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_query_buffer_defaults@@YA?AUsg_buffer_desc@@AEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryBufferDefaults(__IntPtr @return, __IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_query_image_defaults@@YA?AUsg_image_desc@@AEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryImageDefaults(__IntPtr @return, __IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_query_shader_defaults@@YA?AUsg_shader_desc@@AEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryShaderDefaults(__IntPtr @return, __IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_query_pipeline_defaults@@YA?AUsg_pipeline_desc@@AEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryPipelineDefaults(__IntPtr @return, __IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_query_pass_defaults@@YA?AUsg_pass_desc@@AEBU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgQueryPassDefaults(__IntPtr @return, __IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_init_buffer@@YAXUsg_buffer@@AEBUsg_buffer_desc@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgInitBuffer(global::Sokol.SgBuffer.__Internal buf_id, __IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_init_image@@YAXUsg_image@@AEBUsg_image_desc@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgInitImage(global::Sokol.SgImage.__Internal img_id, __IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_init_shader@@YAXUsg_shader@@AEBUsg_shader_desc@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgInitShader(global::Sokol.SgShader.__Internal shd_id, __IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_init_pipeline@@YAXUsg_pipeline@@AEBUsg_pipeline_desc@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgInitPipeline(global::Sokol.SgPipeline.__Internal pip_id, __IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_init_pass@@YAXUsg_pass@@AEBUsg_pass_desc@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgInitPass(global::Sokol.SgPass.__Internal pass_id, __IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_update_buffer@@YAXUsg_buffer@@AEBUsg_range@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SgUpdateBuffer(global::Sokol.SgBuffer.__Internal buf_id, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("sokol-dll", EntryPoint = "?sg_append_buffer@@YAHUsg_buffer@@AEBUsg_range@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SgAppendBuffer(global::Sokol.SgBuffer.__Internal buf_id, __IntPtr data);
        }

        public static void SgShutdown()
        {
            __Internal.SgShutdown();
        }

        public static bool SgIsvalid()
        {
            var __ret = __Internal.SgIsvalid();
            return __ret;
        }

        public static void SgResetStateCache()
        {
            __Internal.SgResetStateCache();
        }

        public static global::Sokol.SgTraceHooks SgInstallTraceHooks(global::Sokol.SgTraceHooks trace_hooks)
        {
            var __arg0 = trace_hooks is null ? __IntPtr.Zero : trace_hooks.__Instance;
            var __ret = new global::Sokol.SgTraceHooks.__Internal();
            __Internal.SgInstallTraceHooks(new IntPtr(&__ret), __arg0);
            return global::Sokol.SgTraceHooks.__CreateInstance(__ret);
        }

        public static void SgPushDebugGroup(string name)
        {
            __Internal.SgPushDebugGroup(name);
        }

        public static void SgPopDebugGroup()
        {
            __Internal.SgPopDebugGroup();
        }

        public static void SgDestroyBuffer(global::Sokol.SgBuffer buf)
        {
            if (ReferenceEquals(buf, null))
                throw new global::System.ArgumentNullException("buf", "Cannot be null because it is passed by value.");
            var __arg0 = buf.__Instance;
            __Internal.SgDestroyBuffer(*(global::Sokol.SgBuffer.__Internal*) __arg0);
        }

        public static void SgDestroyImage(global::Sokol.SgImage img)
        {
            if (ReferenceEquals(img, null))
                throw new global::System.ArgumentNullException("img", "Cannot be null because it is passed by value.");
            var __arg0 = img.__Instance;
            __Internal.SgDestroyImage(*(global::Sokol.SgImage.__Internal*) __arg0);
        }

        public static void SgDestroyShader(global::Sokol.SgShader shd)
        {
            if (ReferenceEquals(shd, null))
                throw new global::System.ArgumentNullException("shd", "Cannot be null because it is passed by value.");
            var __arg0 = shd.__Instance;
            __Internal.SgDestroyShader(*(global::Sokol.SgShader.__Internal*) __arg0);
        }

        public static void SgDestroyPipeline(global::Sokol.SgPipeline pip)
        {
            if (ReferenceEquals(pip, null))
                throw new global::System.ArgumentNullException("pip", "Cannot be null because it is passed by value.");
            var __arg0 = pip.__Instance;
            __Internal.SgDestroyPipeline(*(global::Sokol.SgPipeline.__Internal*) __arg0);
        }

        public static void SgDestroyPass(global::Sokol.SgPass pass)
        {
            if (ReferenceEquals(pass, null))
                throw new global::System.ArgumentNullException("pass", "Cannot be null because it is passed by value.");
            var __arg0 = pass.__Instance;
            __Internal.SgDestroyPass(*(global::Sokol.SgPass.__Internal*) __arg0);
        }

        public static bool SgQueryBufferOverflow(global::Sokol.SgBuffer buf)
        {
            if (ReferenceEquals(buf, null))
                throw new global::System.ArgumentNullException("buf", "Cannot be null because it is passed by value.");
            var __arg0 = buf.__Instance;
            var __ret = __Internal.SgQueryBufferOverflow(*(global::Sokol.SgBuffer.__Internal*) __arg0);
            return __ret;
        }

        public static bool SgQueryBufferWillOverflow(global::Sokol.SgBuffer buf, ulong size)
        {
            if (ReferenceEquals(buf, null))
                throw new global::System.ArgumentNullException("buf", "Cannot be null because it is passed by value.");
            var __arg0 = buf.__Instance;
            var __ret = __Internal.SgQueryBufferWillOverflow(*(global::Sokol.SgBuffer.__Internal*) __arg0, size);
            return __ret;
        }

        public static void SgApplyViewport(int x, int y, int width, int height, bool origin_top_left)
        {
            __Internal.SgApplyViewport(x, y, width, height, origin_top_left);
        }

        public static void SgApplyViewportf(float x, float y, float width, float height, bool origin_top_left)
        {
            __Internal.SgApplyViewportf(x, y, width, height, origin_top_left);
        }

        public static void SgApplyScissorRect(int x, int y, int width, int height, bool origin_top_left)
        {
            __Internal.SgApplyScissorRect(x, y, width, height, origin_top_left);
        }

        public static void SgApplyScissorRectf(float x, float y, float width, float height, bool origin_top_left)
        {
            __Internal.SgApplyScissorRectf(x, y, width, height, origin_top_left);
        }

        public static void SgApplyPipeline(global::Sokol.SgPipeline pip)
        {
            if (ReferenceEquals(pip, null))
                throw new global::System.ArgumentNullException("pip", "Cannot be null because it is passed by value.");
            var __arg0 = pip.__Instance;
            __Internal.SgApplyPipeline(*(global::Sokol.SgPipeline.__Internal*) __arg0);
        }

        public static void SgDraw(int base_element, int num_elements, int num_instances)
        {
            __Internal.SgDraw(base_element, num_elements, num_instances);
        }

        public static void SgEndPass()
        {
            __Internal.SgEndPass();
        }

        public static void SgCommit()
        {
            __Internal.SgCommit();
        }

        public static global::Sokol.SgDesc SgQueryDesc()
        {
            var __ret = new global::Sokol.SgDesc.__Internal();
            __Internal.SgQueryDesc(new IntPtr(&__ret));
            return global::Sokol.SgDesc.__CreateInstance(__ret);
        }

        public static global::Sokol.SgBackend SgQueryBackend()
        {
            var __ret = __Internal.SgQueryBackend();
            return __ret;
        }

        public static global::Sokol.SgFeatures SgQueryFeatures()
        {
            var __ret = new global::Sokol.SgFeatures.__Internal();
            __Internal.SgQueryFeatures(new IntPtr(&__ret));
            return global::Sokol.SgFeatures.__CreateInstance(__ret);
        }

        public static global::Sokol.SgLimits SgQueryLimits()
        {
            var __ret = new global::Sokol.SgLimits.__Internal();
            __Internal.SgQueryLimits(new IntPtr(&__ret));
            return global::Sokol.SgLimits.__CreateInstance(__ret);
        }

        public static global::Sokol.SgPixelformatInfo SgQueryPixelformat(global::Sokol.SgPixelFormat fmt)
        {
            var __ret = new global::Sokol.SgPixelformatInfo.__Internal();
            __Internal.SgQueryPixelformat(new IntPtr(&__ret), fmt);
            return global::Sokol.SgPixelformatInfo.__CreateInstance(__ret);
        }

        public static global::Sokol.SgResourceState SgQueryBufferState(global::Sokol.SgBuffer buf)
        {
            if (ReferenceEquals(buf, null))
                throw new global::System.ArgumentNullException("buf", "Cannot be null because it is passed by value.");
            var __arg0 = buf.__Instance;
            var __ret = __Internal.SgQueryBufferState(*(global::Sokol.SgBuffer.__Internal*) __arg0);
            return __ret;
        }

        public static global::Sokol.SgResourceState SgQueryImageState(global::Sokol.SgImage img)
        {
            if (ReferenceEquals(img, null))
                throw new global::System.ArgumentNullException("img", "Cannot be null because it is passed by value.");
            var __arg0 = img.__Instance;
            var __ret = __Internal.SgQueryImageState(*(global::Sokol.SgImage.__Internal*) __arg0);
            return __ret;
        }

        public static global::Sokol.SgResourceState SgQueryShaderState(global::Sokol.SgShader shd)
        {
            if (ReferenceEquals(shd, null))
                throw new global::System.ArgumentNullException("shd", "Cannot be null because it is passed by value.");
            var __arg0 = shd.__Instance;
            var __ret = __Internal.SgQueryShaderState(*(global::Sokol.SgShader.__Internal*) __arg0);
            return __ret;
        }

        public static global::Sokol.SgResourceState SgQueryPipelineState(global::Sokol.SgPipeline pip)
        {
            if (ReferenceEquals(pip, null))
                throw new global::System.ArgumentNullException("pip", "Cannot be null because it is passed by value.");
            var __arg0 = pip.__Instance;
            var __ret = __Internal.SgQueryPipelineState(*(global::Sokol.SgPipeline.__Internal*) __arg0);
            return __ret;
        }

        public static global::Sokol.SgResourceState SgQueryPassState(global::Sokol.SgPass pass)
        {
            if (ReferenceEquals(pass, null))
                throw new global::System.ArgumentNullException("pass", "Cannot be null because it is passed by value.");
            var __arg0 = pass.__Instance;
            var __ret = __Internal.SgQueryPassState(*(global::Sokol.SgPass.__Internal*) __arg0);
            return __ret;
        }

        public static global::Sokol.SgBufferInfo SgQueryBufferInfo(global::Sokol.SgBuffer buf)
        {
            if (ReferenceEquals(buf, null))
                throw new global::System.ArgumentNullException("buf", "Cannot be null because it is passed by value.");
            var __arg0 = buf.__Instance;
            var __ret = new global::Sokol.SgBufferInfo.__Internal();
            __Internal.SgQueryBufferInfo(new IntPtr(&__ret), *(global::Sokol.SgBuffer.__Internal*) __arg0);
            return global::Sokol.SgBufferInfo.__CreateInstance(__ret);
        }

        public static global::Sokol.SgImageInfo SgQueryImageInfo(global::Sokol.SgImage img)
        {
            if (ReferenceEquals(img, null))
                throw new global::System.ArgumentNullException("img", "Cannot be null because it is passed by value.");
            var __arg0 = img.__Instance;
            var __ret = new global::Sokol.SgImageInfo.__Internal();
            __Internal.SgQueryImageInfo(new IntPtr(&__ret), *(global::Sokol.SgImage.__Internal*) __arg0);
            return global::Sokol.SgImageInfo.__CreateInstance(__ret);
        }

        public static global::Sokol.SgShaderInfo SgQueryShaderInfo(global::Sokol.SgShader shd)
        {
            if (ReferenceEquals(shd, null))
                throw new global::System.ArgumentNullException("shd", "Cannot be null because it is passed by value.");
            var __arg0 = shd.__Instance;
            var __ret = new global::Sokol.SgShaderInfo.__Internal();
            __Internal.SgQueryShaderInfo(new IntPtr(&__ret), *(global::Sokol.SgShader.__Internal*) __arg0);
            return global::Sokol.SgShaderInfo.__CreateInstance(__ret);
        }

        public static global::Sokol.SgPipelineInfo SgQueryPipelineInfo(global::Sokol.SgPipeline pip)
        {
            if (ReferenceEquals(pip, null))
                throw new global::System.ArgumentNullException("pip", "Cannot be null because it is passed by value.");
            var __arg0 = pip.__Instance;
            var __ret = new global::Sokol.SgPipelineInfo.__Internal();
            __Internal.SgQueryPipelineInfo(new IntPtr(&__ret), *(global::Sokol.SgPipeline.__Internal*) __arg0);
            return global::Sokol.SgPipelineInfo.__CreateInstance(__ret);
        }

        public static global::Sokol.SgPassInfo SgQueryPassInfo(global::Sokol.SgPass pass)
        {
            if (ReferenceEquals(pass, null))
                throw new global::System.ArgumentNullException("pass", "Cannot be null because it is passed by value.");
            var __arg0 = pass.__Instance;
            var __ret = new global::Sokol.SgPassInfo.__Internal();
            __Internal.SgQueryPassInfo(new IntPtr(&__ret), *(global::Sokol.SgPass.__Internal*) __arg0);
            return global::Sokol.SgPassInfo.__CreateInstance(__ret);
        }

        public static global::Sokol.SgBuffer SgAllocBuffer()
        {
            var __ret = __Internal.SgAllocBuffer();
            return global::Sokol.SgBuffer.__CreateInstance(__ret);
        }

        public static global::Sokol.SgImage SgAllocImage()
        {
            var __ret = __Internal.SgAllocImage();
            return global::Sokol.SgImage.__CreateInstance(__ret);
        }

        public static global::Sokol.SgShader SgAllocShader()
        {
            var __ret = __Internal.SgAllocShader();
            return global::Sokol.SgShader.__CreateInstance(__ret);
        }

        public static global::Sokol.SgPipeline SgAllocPipeline()
        {
            var __ret = __Internal.SgAllocPipeline();
            return global::Sokol.SgPipeline.__CreateInstance(__ret);
        }

        public static global::Sokol.SgPass SgAllocPass()
        {
            var __ret = __Internal.SgAllocPass();
            return global::Sokol.SgPass.__CreateInstance(__ret);
        }

        public static void SgDeallocBuffer(global::Sokol.SgBuffer buf_id)
        {
            if (ReferenceEquals(buf_id, null))
                throw new global::System.ArgumentNullException("buf_id", "Cannot be null because it is passed by value.");
            var __arg0 = buf_id.__Instance;
            __Internal.SgDeallocBuffer(*(global::Sokol.SgBuffer.__Internal*) __arg0);
        }

        public static void SgDeallocImage(global::Sokol.SgImage img_id)
        {
            if (ReferenceEquals(img_id, null))
                throw new global::System.ArgumentNullException("img_id", "Cannot be null because it is passed by value.");
            var __arg0 = img_id.__Instance;
            __Internal.SgDeallocImage(*(global::Sokol.SgImage.__Internal*) __arg0);
        }

        public static void SgDeallocShader(global::Sokol.SgShader shd_id)
        {
            if (ReferenceEquals(shd_id, null))
                throw new global::System.ArgumentNullException("shd_id", "Cannot be null because it is passed by value.");
            var __arg0 = shd_id.__Instance;
            __Internal.SgDeallocShader(*(global::Sokol.SgShader.__Internal*) __arg0);
        }

        public static void SgDeallocPipeline(global::Sokol.SgPipeline pip_id)
        {
            if (ReferenceEquals(pip_id, null))
                throw new global::System.ArgumentNullException("pip_id", "Cannot be null because it is passed by value.");
            var __arg0 = pip_id.__Instance;
            __Internal.SgDeallocPipeline(*(global::Sokol.SgPipeline.__Internal*) __arg0);
        }

        public static void SgDeallocPass(global::Sokol.SgPass pass_id)
        {
            if (ReferenceEquals(pass_id, null))
                throw new global::System.ArgumentNullException("pass_id", "Cannot be null because it is passed by value.");
            var __arg0 = pass_id.__Instance;
            __Internal.SgDeallocPass(*(global::Sokol.SgPass.__Internal*) __arg0);
        }

        public static bool SgUninitBuffer(global::Sokol.SgBuffer buf_id)
        {
            if (ReferenceEquals(buf_id, null))
                throw new global::System.ArgumentNullException("buf_id", "Cannot be null because it is passed by value.");
            var __arg0 = buf_id.__Instance;
            var __ret = __Internal.SgUninitBuffer(*(global::Sokol.SgBuffer.__Internal*) __arg0);
            return __ret;
        }

        public static bool SgUninitImage(global::Sokol.SgImage img_id)
        {
            if (ReferenceEquals(img_id, null))
                throw new global::System.ArgumentNullException("img_id", "Cannot be null because it is passed by value.");
            var __arg0 = img_id.__Instance;
            var __ret = __Internal.SgUninitImage(*(global::Sokol.SgImage.__Internal*) __arg0);
            return __ret;
        }

        public static bool SgUninitShader(global::Sokol.SgShader shd_id)
        {
            if (ReferenceEquals(shd_id, null))
                throw new global::System.ArgumentNullException("shd_id", "Cannot be null because it is passed by value.");
            var __arg0 = shd_id.__Instance;
            var __ret = __Internal.SgUninitShader(*(global::Sokol.SgShader.__Internal*) __arg0);
            return __ret;
        }

        public static bool SgUninitPipeline(global::Sokol.SgPipeline pip_id)
        {
            if (ReferenceEquals(pip_id, null))
                throw new global::System.ArgumentNullException("pip_id", "Cannot be null because it is passed by value.");
            var __arg0 = pip_id.__Instance;
            var __ret = __Internal.SgUninitPipeline(*(global::Sokol.SgPipeline.__Internal*) __arg0);
            return __ret;
        }

        public static bool SgUninitPass(global::Sokol.SgPass pass_id)
        {
            if (ReferenceEquals(pass_id, null))
                throw new global::System.ArgumentNullException("pass_id", "Cannot be null because it is passed by value.");
            var __arg0 = pass_id.__Instance;
            var __ret = __Internal.SgUninitPass(*(global::Sokol.SgPass.__Internal*) __arg0);
            return __ret;
        }

        public static void SgFailBuffer(global::Sokol.SgBuffer buf_id)
        {
            if (ReferenceEquals(buf_id, null))
                throw new global::System.ArgumentNullException("buf_id", "Cannot be null because it is passed by value.");
            var __arg0 = buf_id.__Instance;
            __Internal.SgFailBuffer(*(global::Sokol.SgBuffer.__Internal*) __arg0);
        }

        public static void SgFailImage(global::Sokol.SgImage img_id)
        {
            if (ReferenceEquals(img_id, null))
                throw new global::System.ArgumentNullException("img_id", "Cannot be null because it is passed by value.");
            var __arg0 = img_id.__Instance;
            __Internal.SgFailImage(*(global::Sokol.SgImage.__Internal*) __arg0);
        }

        public static void SgFailShader(global::Sokol.SgShader shd_id)
        {
            if (ReferenceEquals(shd_id, null))
                throw new global::System.ArgumentNullException("shd_id", "Cannot be null because it is passed by value.");
            var __arg0 = shd_id.__Instance;
            __Internal.SgFailShader(*(global::Sokol.SgShader.__Internal*) __arg0);
        }

        public static void SgFailPipeline(global::Sokol.SgPipeline pip_id)
        {
            if (ReferenceEquals(pip_id, null))
                throw new global::System.ArgumentNullException("pip_id", "Cannot be null because it is passed by value.");
            var __arg0 = pip_id.__Instance;
            __Internal.SgFailPipeline(*(global::Sokol.SgPipeline.__Internal*) __arg0);
        }

        public static void SgFailPass(global::Sokol.SgPass pass_id)
        {
            if (ReferenceEquals(pass_id, null))
                throw new global::System.ArgumentNullException("pass_id", "Cannot be null because it is passed by value.");
            var __arg0 = pass_id.__Instance;
            __Internal.SgFailPass(*(global::Sokol.SgPass.__Internal*) __arg0);
        }

        public static global::Sokol.SgContext SgSetupContext()
        {
            var __ret = __Internal.SgSetupContext();
            return global::Sokol.SgContext.__CreateInstance(__ret);
        }

        public static void SgActivateContext(global::Sokol.SgContext ctx_id)
        {
            if (ReferenceEquals(ctx_id, null))
                throw new global::System.ArgumentNullException("ctx_id", "Cannot be null because it is passed by value.");
            var __arg0 = ctx_id.__Instance;
            __Internal.SgActivateContext(*(global::Sokol.SgContext.__Internal*) __arg0);
        }

        public static void SgDiscardContext(global::Sokol.SgContext ctx_id)
        {
            if (ReferenceEquals(ctx_id, null))
                throw new global::System.ArgumentNullException("ctx_id", "Cannot be null because it is passed by value.");
            var __arg0 = ctx_id.__Instance;
            __Internal.SgDiscardContext(*(global::Sokol.SgContext.__Internal*) __arg0);
        }

        public static __IntPtr SgD3d11Device()
        {
            var __ret = __Internal.SgD3d11Device();
            return __ret;
        }

        public static __IntPtr SgMtlDevice()
        {
            var __ret = __Internal.SgMtlDevice();
            return __ret;
        }

        public static __IntPtr SgMtlRenderCommandEncoder()
        {
            var __ret = __Internal.SgMtlRenderCommandEncoder();
            return __ret;
        }

        public static void SgSetup(global::Sokol.SgDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            __Internal.SgSetup(__arg0);
        }

        public static global::Sokol.SgBuffer SgMakeBuffer(global::Sokol.SgBufferDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            var __ret = __Internal.SgMakeBuffer(__arg0);
            return global::Sokol.SgBuffer.__CreateInstance(__ret);
        }

        public static global::Sokol.SgImage SgMakeImage(global::Sokol.SgImageDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            var __ret = __Internal.SgMakeImage(__arg0);
            return global::Sokol.SgImage.__CreateInstance(__ret);
        }

        public static global::Sokol.SgShader SgMakeShader(global::Sokol.SgShaderDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            var __ret = __Internal.SgMakeShader(__arg0);
            return global::Sokol.SgShader.__CreateInstance(__ret);
        }

        public static global::Sokol.SgPipeline SgMakePipeline(global::Sokol.SgPipelineDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            var __ret = __Internal.SgMakePipeline(__arg0);
            return global::Sokol.SgPipeline.__CreateInstance(__ret);
        }

        public static global::Sokol.SgPass SgMakePass(global::Sokol.SgPassDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            var __ret = __Internal.SgMakePass(__arg0);
            return global::Sokol.SgPass.__CreateInstance(__ret);
        }

        public static void SgUpdateImage(global::Sokol.SgImage img, global::Sokol.SgImageData data)
        {
            if (ReferenceEquals(img, null))
                throw new global::System.ArgumentNullException("img", "Cannot be null because it is passed by value.");
            var __arg0 = img.__Instance;
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = data.__Instance;
            __Internal.SgUpdateImage(*(global::Sokol.SgImage.__Internal*) __arg0, __arg1);
        }

        public static void SgBeginDefaultPass(global::Sokol.SgPassAction pass_action, int width, int height)
        {
            if (ReferenceEquals(pass_action, null))
                throw new global::System.ArgumentNullException("pass_action", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pass_action.__Instance;
            __Internal.SgBeginDefaultPass(__arg0, width, height);
        }

        public static void SgBeginDefaultPassf(global::Sokol.SgPassAction pass_action, float width, float height)
        {
            if (ReferenceEquals(pass_action, null))
                throw new global::System.ArgumentNullException("pass_action", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pass_action.__Instance;
            __Internal.SgBeginDefaultPassf(__arg0, width, height);
        }

        public static void SgBeginPass(global::Sokol.SgPass pass, global::Sokol.SgPassAction pass_action)
        {
            if (ReferenceEquals(pass, null))
                throw new global::System.ArgumentNullException("pass", "Cannot be null because it is passed by value.");
            var __arg0 = pass.__Instance;
            if (ReferenceEquals(pass_action, null))
                throw new global::System.ArgumentNullException("pass_action", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pass_action.__Instance;
            __Internal.SgBeginPass(*(global::Sokol.SgPass.__Internal*) __arg0, __arg1);
        }

        public static void SgApplyBindings(global::Sokol.SgBindings bindings)
        {
            if (ReferenceEquals(bindings, null))
                throw new global::System.ArgumentNullException("bindings", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = bindings.__Instance;
            __Internal.SgApplyBindings(__arg0);
        }

        public static void SgApplyUniforms(global::Sokol.SgShaderStage stage, int ub_index, global::Sokol.SgRange data)
        {
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = data.__Instance;
            __Internal.SgApplyUniforms(stage, ub_index, __arg2);
        }

        public static global::Sokol.SgBufferDesc SgQueryBufferDefaults(global::Sokol.SgBufferDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            var __ret = new global::Sokol.SgBufferDesc.__Internal();
            __Internal.SgQueryBufferDefaults(new IntPtr(&__ret), __arg0);
            return global::Sokol.SgBufferDesc.__CreateInstance(__ret);
        }

        public static global::Sokol.SgImageDesc SgQueryImageDefaults(global::Sokol.SgImageDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            var __ret = new global::Sokol.SgImageDesc.__Internal();
            __Internal.SgQueryImageDefaults(new IntPtr(&__ret), __arg0);
            return global::Sokol.SgImageDesc.__CreateInstance(__ret);
        }

        public static global::Sokol.SgShaderDesc SgQueryShaderDefaults(global::Sokol.SgShaderDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            var __ret = new global::Sokol.SgShaderDesc.__Internal();
            __Internal.SgQueryShaderDefaults(new IntPtr(&__ret), __arg0);
            return global::Sokol.SgShaderDesc.__CreateInstance(__ret);
        }

        public static global::Sokol.SgPipelineDesc SgQueryPipelineDefaults(global::Sokol.SgPipelineDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            var __ret = new global::Sokol.SgPipelineDesc.__Internal();
            __Internal.SgQueryPipelineDefaults(new IntPtr(&__ret), __arg0);
            return global::Sokol.SgPipelineDesc.__CreateInstance(__ret);
        }

        public static global::Sokol.SgPassDesc SgQueryPassDefaults(global::Sokol.SgPassDesc desc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = desc.__Instance;
            var __ret = new global::Sokol.SgPassDesc.__Internal();
            __Internal.SgQueryPassDefaults(new IntPtr(&__ret), __arg0);
            return global::Sokol.SgPassDesc.__CreateInstance(__ret);
        }

        public static void SgInitBuffer(global::Sokol.SgBuffer buf_id, global::Sokol.SgBufferDesc desc)
        {
            if (ReferenceEquals(buf_id, null))
                throw new global::System.ArgumentNullException("buf_id", "Cannot be null because it is passed by value.");
            var __arg0 = buf_id.__Instance;
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = desc.__Instance;
            __Internal.SgInitBuffer(*(global::Sokol.SgBuffer.__Internal*) __arg0, __arg1);
        }

        public static void SgInitImage(global::Sokol.SgImage img_id, global::Sokol.SgImageDesc desc)
        {
            if (ReferenceEquals(img_id, null))
                throw new global::System.ArgumentNullException("img_id", "Cannot be null because it is passed by value.");
            var __arg0 = img_id.__Instance;
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = desc.__Instance;
            __Internal.SgInitImage(*(global::Sokol.SgImage.__Internal*) __arg0, __arg1);
        }

        public static void SgInitShader(global::Sokol.SgShader shd_id, global::Sokol.SgShaderDesc desc)
        {
            if (ReferenceEquals(shd_id, null))
                throw new global::System.ArgumentNullException("shd_id", "Cannot be null because it is passed by value.");
            var __arg0 = shd_id.__Instance;
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = desc.__Instance;
            __Internal.SgInitShader(*(global::Sokol.SgShader.__Internal*) __arg0, __arg1);
        }

        public static void SgInitPipeline(global::Sokol.SgPipeline pip_id, global::Sokol.SgPipelineDesc desc)
        {
            if (ReferenceEquals(pip_id, null))
                throw new global::System.ArgumentNullException("pip_id", "Cannot be null because it is passed by value.");
            var __arg0 = pip_id.__Instance;
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = desc.__Instance;
            __Internal.SgInitPipeline(*(global::Sokol.SgPipeline.__Internal*) __arg0, __arg1);
        }

        public static void SgInitPass(global::Sokol.SgPass pass_id, global::Sokol.SgPassDesc desc)
        {
            if (ReferenceEquals(pass_id, null))
                throw new global::System.ArgumentNullException("pass_id", "Cannot be null because it is passed by value.");
            var __arg0 = pass_id.__Instance;
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = desc.__Instance;
            __Internal.SgInitPass(*(global::Sokol.SgPass.__Internal*) __arg0, __arg1);
        }

        public static void SgUpdateBuffer(global::Sokol.SgBuffer buf_id, global::Sokol.SgRange data)
        {
            if (ReferenceEquals(buf_id, null))
                throw new global::System.ArgumentNullException("buf_id", "Cannot be null because it is passed by value.");
            var __arg0 = buf_id.__Instance;
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = data.__Instance;
            __Internal.SgUpdateBuffer(*(global::Sokol.SgBuffer.__Internal*) __arg0, __arg1);
        }

        public static int SgAppendBuffer(global::Sokol.SgBuffer buf_id, global::Sokol.SgRange data)
        {
            if (ReferenceEquals(buf_id, null))
                throw new global::System.ArgumentNullException("buf_id", "Cannot be null because it is passed by value.");
            var __arg0 = buf_id.__Instance;
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = data.__Instance;
            var __ret = __Internal.SgAppendBuffer(*(global::Sokol.SgBuffer.__Internal*) __arg0, __arg1);
            return __ret;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr_ulong___IntPtr(ulong size, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(__IntPtr ptr, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_();

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(__IntPtr __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_string8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_string8___IntPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string __0, __IntPtr __1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_Sokol_sg_buffer___Internal___IntPtr(__IntPtr desc, global::Sokol.SgBuffer.__Internal result, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_Sokol_sg_image___Internal___IntPtr(__IntPtr desc, global::Sokol.SgImage.__Internal result, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_Sokol_sg_shader___Internal___IntPtr(__IntPtr desc, global::Sokol.SgShader.__Internal result, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_Sokol_sg_pipeline___Internal___IntPtr(__IntPtr desc, global::Sokol.SgPipeline.__Internal result, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_Sokol_sg_pass___Internal___IntPtr(__IntPtr desc, global::Sokol.SgPass.__Internal result, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_buffer___Internal___IntPtr(global::Sokol.SgBuffer.__Internal buf, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_image___Internal___IntPtr(global::Sokol.SgImage.__Internal img, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_shader___Internal___IntPtr(global::Sokol.SgShader.__Internal shd, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_pipeline___Internal___IntPtr(global::Sokol.SgPipeline.__Internal pip, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_pass___Internal___IntPtr(global::Sokol.SgPass.__Internal pass, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_buffer___Internal___IntPtr___IntPtr(global::Sokol.SgBuffer.__Internal buf, __IntPtr data, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_image___Internal___IntPtr___IntPtr(global::Sokol.SgImage.__Internal img, __IntPtr data, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_buffer___Internal___IntPtr_int___IntPtr(global::Sokol.SgBuffer.__Internal buf, __IntPtr data, int result, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_int_int___IntPtr(__IntPtr pass_action, int width, int height, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_pass___Internal___IntPtr___IntPtr(global::Sokol.SgPass.__Internal pass, __IntPtr pass_action, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_int_int_int_int_bool___IntPtr(int x, int y, int width, int height, [MarshalAs(UnmanagedType.I1)] bool origin_top_left, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_shader_stage_int___IntPtr___IntPtr(global::Sokol.SgShaderStage stage, int ub_index, __IntPtr data, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_int_int_int___IntPtr(int base_element, int num_elements, int num_instances, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_shader___Internal___IntPtr___IntPtr(global::Sokol.SgShader.__Internal shd_id, __IntPtr desc, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sokol_sg_pipeline___Internal___IntPtr___IntPtr(global::Sokol.SgPipeline.__Internal pip_id, __IntPtr desc, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr();

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr __0);
    }
}
